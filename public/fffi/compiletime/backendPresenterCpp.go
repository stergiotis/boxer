package compiletime

import (
	"bytes"
	"fmt"
	"github.com/stergiotis/boxer/public/fffi/runtime"
	"github.com/stergiotis/boxer/public/observability/eh"
	"github.com/stergiotis/boxer/public/observability/eh/eb"
	"go/ast"
	"io"
)

type CodeTransformerBackendPresenterCpp struct {
	builder *bytes.Buffer
	namer   *Namer
}

var _ CodeTransformerBackend = (*CodeTransformerBackendPresenterCpp)(nil)

func NewCodeTransformerBackendPresenterCpp(namer *Namer) *CodeTransformerBackendPresenterCpp {
	return &CodeTransformerBackendPresenterCpp{
		builder: &bytes.Buffer{},
		namer:   namer,
	}
}
func (inst *CodeTransformerBackendPresenterCpp) AddFunction(decl *ast.FuncDecl, resolver TypeResolver, id runtime.FuncProcId) (err error) {
	t := decl.Type
	if t.TypeParams != nil {
		return eh.New("type params are currently not implemented")
	}

	var paramNames, paramGoTypes, resultNames, resultGoTypes []string
	paramNames, paramGoTypes, _, _, resultNames, resultGoTypes, _, _, _, err = getParamsAndResultTypes(decl, resolver)
	if err != nil {
		return eb.Build().Str("name", decl.Name.Name).Errorf("unable to get params and result types: %w", err)
	}

	b := inst.builder
	_, _ = b.WriteString("case ")
	_, _ = b.WriteString(fmt.Sprintf("0x%08x", id))
	_, _ = b.WriteString(":\n")
	_, _ = b.WriteString("  {\n")
	_, _ = b.WriteString("    FFFI_FUNCTION_INVOCATION(\"")
	_, _ = b.WriteString(decl.Name.Name)
	_, _ = b.WriteString("\")\n")
	for i, name := range paramNames {
		var expr string
		expr, err = inst.namer.GoTypeNameToRecvExprCpp(paramGoTypes[i])
		if err != nil {
			err = eb.Build().Str("name", name).Str("goType", paramGoTypes[i]).Errorf("unable to determine send/recv function name suffix from go type: %w", err)
			return
		}
		_, _ = b.WriteString("    auto ")
		_, _ = b.WriteString(name)
		_, _ = b.WriteString(" = ")
		_, _ = b.WriteString(expr)
		_, _ = b.WriteString(";\n")
	}

	if len(resultNames) > 0 {
		for i, name := range resultNames {
			var typeNameCpp string
			typeNameCpp, err = inst.namer.GoTypeNameToCppTypeName(resultGoTypes[i])
			if err != nil {
				err = eb.Build().Str("name", name).Str("goType", resultGoTypes[i]).Errorf("unable to convert go type to cpp type: %w", err)
				return
			}

			_, _ = b.WriteString("    ")
			_, _ = b.WriteString(typeNameCpp)
			_, _ = b.WriteString(" ")
			_, _ = b.WriteString(name)
			_, _ = b.WriteString(";\n")
		}
	}

	var callCode string
	if decl.Body == nil {
		err = eh.New("no body in function declaration")
		return
	}
	lst := decl.Body.List
	if lst == nil || len(lst) == 0 {
		err = eh.New("no body statements in function declaration")
		return
	}
	_, _ = b.WriteString("    {\n") // begin new scope to allow shadowing the return values declared above
	_, callCode, _, err = splitIdlBody(lst)
	if err != nil {
		return eb.Build().Str("name", decl.Name.Name).Errorf("unable to extract call code from body: %w", err)
	}
	_, _ = b.WriteString("    ")
	_, _ = b.WriteString(callCode)
	_, _ = b.WriteString(";\n")

	if len(resultNames) != 0 {
		_, _ = b.WriteString("    sendEmptyString();\n") // FIXME error handling/nothrow
		for i, n := range resultNames {
			var expr string
			expr, err = inst.namer.GoTypeNameToSendExprCpp(resultGoTypes[i], n)
			if err != nil {
				err = eb.Build().Str("goType", resultGoTypes[i]).Errorf("unable to compose send result function call: %w", err)
				return
			}
			_, _ = b.WriteString("    ")
			_, _ = b.WriteString(expr)
			_, _ = b.WriteString(";\n")
		}
		_, _ = b.WriteString("    flushSend();\n")
	}
	_, _ = b.WriteString("  }\n")
	_, _ = b.WriteString("  }\n")
	_, _ = b.WriteString("  break;\n")

	return
}

func (inst *CodeTransformerBackendPresenterCpp) emitDispatcher(out io.Writer) (n int, err error) {
	return emitBuilderWithProlog(out, inst.builder, `// Code generated by fffi generator; DO NOT EDIT.
`)
}
func (inst *CodeTransformerBackendPresenterCpp) Emit(out io.Writer) (n int, err error) {
	return inst.emitDispatcher(out)
}

func (inst *CodeTransformerBackendPresenterCpp) Reset() {
	inst.builder.Reset()
}
