// Code generated by fffi generator; DO NOT EDIT.
// -- deactivated -- // //go:build fffi_idl_code

package implot
import "github.com/stergiotis/boxer/public/imzero/imgui"

import "github.com/stergiotis/boxer/public/fffi/runtime"

// -- deactivated -- // import . "github.com/stergiotis/boxer/public/imzero/imgui"

func GetLocationPos(outer_rect imgui.ImRect, inner_size imgui.ImVec2, loc ImPlotLocation, pad imgui.ImVec2) (r imgui.ImVec2) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000003e8)
	runtime.AddFloat32Array4Arg(_f, outer_rect)
	runtime.AddComplex64Arg(_f, inner_size)
	runtime.AddIntArg(_f, loc)
	runtime.AddComplex64Arg(_f, pad)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = imgui.ImVec2(runtime.GetComplex64Retr[

	// SetupAxisTicks Sets an axis' ticks and optionally the labels. To keep the default ticks, set keep_default=true.
	//foreign code:
//  
//  size_t n_labels;
//  auto ary_labels = convertNullSeparatedStringArrayToArray(labels,n_labels);
//  ImPlot::SetupAxisTicks(idx, values, (int)n_labels, ary_labels, show_default);
//
	complex64](_f))
	return
}

func SetupAxisTicks(idx ImAxis, values []float64, labels NullSeparatedStringArray, show_default bool) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003e9)
	runtime.AddIntArg(_f, idx)
	runtime.AddFloat64SliceArg(_f, values)
	runtime.AddStringArg(_f, labels)
	runtime.AddBoolArg(_f, show_default)
	_f.CallProcedure()

}

// SetupAxisTicks Sets an axis' ticks and optionally the labels for the next plot. To keep the default ticks, set keep_default=true.
//foreign code:
//  
//  size_t n_labels;
//  auto ary_labels = convertNullSeparatedStringArrayToArray(labels,n_labels);
//  ImPlot::SetupAxisTicks(idx, v_min, v_max, (int)n_labels, ary_labels, show_default);
//
func SetupAxisTicksRange(idx ImAxis, v_min float64, v_max float64, n_ticks int, labels NullSeparatedStringArray, show_default bool) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003ea)
	runtime.AddIntArg(_f, idx)
	runtime.AddFloat64Arg(_f, v_min)
	runtime.AddFloat64Arg(_f, v_max)
	runtime.AddIntArg(_f, n_ticks)
	runtime.AddStringArg(_f, labels)
	runtime.AddBoolArg(_f, show_default)
	_f.CallProcedure()

}

// Annotation Shows an annotation callout at a chosen point. Clamping keeps annotations in the plot area. Annotations are always rendered on top.
//foreign code:
//  ImPlot::Annotation(x, y, col, pix_offset, clamp, "%.*s", (int)getStringLength(text),text)
func AnnotationText(x float64, y float64, col imgui.ImVec4, pix_offset imgui.ImVec2, clamp bool, text string) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003eb)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat32Array4Arg(_f, col)
	runtime.AddComplex64Arg(_f, pix_offset)
	runtime.AddBoolArg(_f, clamp)
	runtime.AddStringArg(_f, text)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code
// -- deactivated -- // package implot

// -- deactivated -- // import . "github.com/stergiotis/boxer/public/imzero/imgui"

var _ = imgui.ImVec2(0)

type ImAxis int

const (
	ImAxis_X1           = ImAxis(0) // enabled by default
	ImAxis_X2           = iota      // disabled by default
	ImAxis_X3           = iota      // disabled by default
	ImAxis_Y1           = iota      // enabled by default
	ImAxis_Y2           = iota      // disabled by default
	ImAxis_Y3           = iota      // disabled by default
	ImAxis_COUNT        = iota
	ImAxis_AUTO  ImAxis = -1 // auto value
)

type ImPlotFlags int

const (
	ImPlotFlags_None                    = ImPlotFlags(0)      // default
	ImPlotFlags_NoTitle                 = ImPlotFlags(1 << 0) // the plot title will not be displayed (titles are also hidden if preceeded by double hashes, e.g. "##MyPlot")
	ImPlotFlags_NoLegend                = ImPlotFlags(1 << 1) // the legend will not be displayed
	ImPlotFlags_NoMouseText             = ImPlotFlags(1 << 2) // the mouse position, in plot coordinates, will not be displayed inside of the plot
	ImPlotFlags_NoInputs                = ImPlotFlags(1 << 3) // the user will not be able to interact with the plot
	ImPlotFlags_NoMenus                 = ImPlotFlags(1 << 4) // the user will not be able to open context menus
	ImPlotFlags_NoBoxSelect             = ImPlotFlags(1 << 5) // the user will not be able to box-select
	ImPlotFlags_NoFrame                 = ImPlotFlags(1 << 6) // the imgui.ImGui frame will not be rendered
	ImPlotFlags_Equal                   = ImPlotFlags(1 << 7) // x and y axes pairs will be constrained to have the same units/pixel
	ImPlotFlags_Crosshairs              = ImPlotFlags(1 << 8) // the default mouse cursor will be replaced with a crosshair when hovered
	ImPlotFlags_CanvasOnly              = ImPlotFlags(ImPlotFlags_NoTitle | ImPlotFlags_NoLegend | ImPlotFlags_NoMenus | ImPlotFlags_NoBoxSelect | ImPlotFlags_NoMouseText)
	ImPlotFlags_AUTO        ImPlotFlags = -1 // auto value
)

type ImPlotAxisFlags int

const (
	ImPlotAxisFlags_None                          = ImPlotAxisFlags(0)       // default
	ImPlotAxisFlags_NoLabel                       = ImPlotAxisFlags(1 << 0)  // the axis label will not be displayed (axis labels are also hidden if the supplied string name is nullptr)
	ImPlotAxisFlags_NoGridLines                   = ImPlotAxisFlags(1 << 1)  // no grid lines will be displayed
	ImPlotAxisFlags_NoTickMarks                   = ImPlotAxisFlags(1 << 2)  // no tick marks will be displayed
	ImPlotAxisFlags_NoTickLabels                  = ImPlotAxisFlags(1 << 3)  // no text labels will be displayed
	ImPlotAxisFlags_NoInitialFit                  = ImPlotAxisFlags(1 << 4)  // axis will not be initially fit to data extents on the first rendered frame
	ImPlotAxisFlags_NoMenus                       = ImPlotAxisFlags(1 << 5)  // the user will not be able to open context menus with right-click
	ImPlotAxisFlags_NoSideSwitch                  = ImPlotAxisFlags(1 << 6)  // the user will not be able to switch the axis side by dragging it
	ImPlotAxisFlags_NoHighlight                   = ImPlotAxisFlags(1 << 7)  // the axis will not have its background highlighted when hovered or held
	ImPlotAxisFlags_Opposite                      = ImPlotAxisFlags(1 << 8)  // axis ticks and labels will be rendered on the conventionally opposite side (i.e, right or top)
	ImPlotAxisFlags_Foreground                    = ImPlotAxisFlags(1 << 9)  // grid lines will be displayed in the foreground (i.e. on top of data) instead of the background
	ImPlotAxisFlags_Invert                        = ImPlotAxisFlags(1 << 10) // the axis will be inverted
	ImPlotAxisFlags_AutoFit                       = ImPlotAxisFlags(1 << 11) // axis will be auto-fitting to data extents
	ImPlotAxisFlags_RangeFit                      = ImPlotAxisFlags(1 << 12) // axis will only fit points if the point is in the visible range of the **orthogonal** axis
	ImPlotAxisFlags_PanStretch                    = ImPlotAxisFlags(1 << 13) // panning in a locked or constrained state will cause the axis to stretch if possible
	ImPlotAxisFlags_LockMin                       = ImPlotAxisFlags(1 << 14) // the axis minimum value will be locked when panning/zooming
	ImPlotAxisFlags_LockMax                       = ImPlotAxisFlags(1 << 15) // the axis maximum value will be locked when panning/zooming
	ImPlotAxisFlags_Lock                          = ImPlotAxisFlags(ImPlotAxisFlags_LockMin | ImPlotAxisFlags_LockMax)
	ImPlotAxisFlags_NoDecorations                 = ImPlotAxisFlags(ImPlotAxisFlags_NoLabel | ImPlotAxisFlags_NoGridLines | ImPlotAxisFlags_NoTickMarks | ImPlotAxisFlags_NoTickLabels)
	ImPlotAxisFlags_AuxDefault                    = ImPlotAxisFlags(ImPlotAxisFlags_NoGridLines | ImPlotAxisFlags_Opposite)
	ImPlotAxisFlags_AUTO          ImPlotAxisFlags = -1 // auto value
)

type ImPlotSubplotFlags int

const (
	ImPlotSubplotFlags_None                          = ImPlotSubplotFlags(0)      // default
	ImPlotSubplotFlags_NoTitle                       = ImPlotSubplotFlags(1 << 0) // the subplot title will not be displayed (titles are also hidden if preceeded by double hashes, e.g. "##MySubplot")
	ImPlotSubplotFlags_NoLegend                      = ImPlotSubplotFlags(1 << 1) // the legend will not be displayed (only applicable if ImPlotSubplotFlags_ShareItems is enabled)
	ImPlotSubplotFlags_NoMenus                       = ImPlotSubplotFlags(1 << 2) // the user will not be able to open context menus with right-click
	ImPlotSubplotFlags_NoResize                      = ImPlotSubplotFlags(1 << 3) // resize splitters between subplot cells will be not be provided
	ImPlotSubplotFlags_NoAlign                       = ImPlotSubplotFlags(1 << 4) // subplot edges will not be aligned vertically or horizontally
	ImPlotSubplotFlags_ShareItems                    = ImPlotSubplotFlags(1 << 5) // items across all subplots will be shared and rendered into a single legend entry
	ImPlotSubplotFlags_LinkRows                      = ImPlotSubplotFlags(1 << 6) // link the y-axis limits of all plots in each row (does not apply to auxiliary axes)
	ImPlotSubplotFlags_LinkCols                      = ImPlotSubplotFlags(1 << 7) // link the x-axis limits of all plots in each column (does not apply to auxiliary axes)
	ImPlotSubplotFlags_LinkAllX                      = ImPlotSubplotFlags(1 << 8) // link the x-axis limits in every plot in the subplot (does not apply to auxiliary axes)
	ImPlotSubplotFlags_LinkAllY                      = ImPlotSubplotFlags(1 << 9) // link the y-axis limits in every plot in the subplot (does not apply to auxiliary axes)
	ImPlotSubplotFlags_ColMajor                      = ImPlotSubplotFlags(1 << 10)
	ImPlotSubplotFlags_AUTO       ImPlotSubplotFlags = -1 // auto value
)

type ImPlotLegendFlags int

const (
	ImPlotLegendFlags_None                              = ImPlotLegendFlags(0)      // default
	ImPlotLegendFlags_NoButtons                         = ImPlotLegendFlags(1 << 0) // legend icons will not function as hide/show buttons
	ImPlotLegendFlags_NoHighlightItem                   = ImPlotLegendFlags(1 << 1) // plot items will not be highlighted when their legend entry is hovered
	ImPlotLegendFlags_NoHighlightAxis                   = ImPlotLegendFlags(1 << 2) // axes will not be highlighted when legend entries are hovered (only relevant if x/y-axis count > 1)
	ImPlotLegendFlags_NoMenus                           = ImPlotLegendFlags(1 << 3) // the user will not be able to open context menus with right-click
	ImPlotLegendFlags_Outside                           = ImPlotLegendFlags(1 << 4) // legend will be rendered outside of the plot area
	ImPlotLegendFlags_Horizontal                        = ImPlotLegendFlags(1 << 5) // legend entries will be displayed horizontally
	ImPlotLegendFlags_Sort                              = ImPlotLegendFlags(1 << 6) // legend entries will be displayed in alphabetical order
	ImPlotLegendFlags_AUTO            ImPlotLegendFlags = -1                        // auto value
)

type ImPlotMouseTextFlags int

const (
	ImPlotMouseTextFlags_None                            = ImPlotMouseTextFlags(0)      // default
	ImPlotMouseTextFlags_NoAuxAxes                       = ImPlotMouseTextFlags(1 << 0) // only show the mouse position for primary axes
	ImPlotMouseTextFlags_NoFormat                        = ImPlotMouseTextFlags(1 << 1) // axes label formatters won't be used to render text
	ImPlotMouseTextFlags_ShowAlways                      = ImPlotMouseTextFlags(1 << 2) // always display mouse position even if plot not hovered
	ImPlotMouseTextFlags_AUTO       ImPlotMouseTextFlags = -1                           // auto value
)

type ImPlotDragToolFlags int

const (
	ImPlotDragToolFlags_None                          = ImPlotDragToolFlags(0)      // default
	ImPlotDragToolFlags_NoCursors                     = ImPlotDragToolFlags(1 << 0) // drag tools won't change cursor icons when hovered or held
	ImPlotDragToolFlags_NoFit                         = ImPlotDragToolFlags(1 << 1) // the drag tool won't be considered for plot fits
	ImPlotDragToolFlags_NoInputs                      = ImPlotDragToolFlags(1 << 2) // lock the tool from user inputs
	ImPlotDragToolFlags_Delayed                       = ImPlotDragToolFlags(1 << 3) // tool rendering will be delayed one frame; useful when applying position-constraints
	ImPlotDragToolFlags_AUTO      ImPlotDragToolFlags = -1                          // auto value
)

type ImPlotColormapScaleFlags int

const (
	ImPlotColormapScaleFlags_None                              = ImPlotColormapScaleFlags(0)      // default
	ImPlotColormapScaleFlags_NoLabel                           = ImPlotColormapScaleFlags(1 << 0) // the colormap axis label will not be displayed
	ImPlotColormapScaleFlags_Opposite                          = ImPlotColormapScaleFlags(1 << 1) // render the colormap label and tick labels on the opposite side
	ImPlotColormapScaleFlags_Invert                            = ImPlotColormapScaleFlags(1 << 2) // invert the colormap bar and axis scale (this only affects rendering; if you only want to reverse the scale mapping, make scale_min > scale_max)
	ImPlotColormapScaleFlags_AUTO     ImPlotColormapScaleFlags = -1                               // auto value
)

type ImPlotItemFlags int

const (
	ImPlotItemFlags_None                     = ImPlotItemFlags(0)
	ImPlotItemFlags_NoLegend                 = ImPlotItemFlags(1 << 0) // the item won't have a legend entry displayed
	ImPlotItemFlags_NoFit                    = ImPlotItemFlags(1 << 1) // the item won't be considered for plot fits
	ImPlotItemFlags_AUTO     ImPlotItemFlags = -1                      // auto value
)

type ImPlotLineFlags int

const (
	ImPlotLineFlags_None                     = ImPlotLineFlags(0)       // default
	ImPlotLineFlags_Segments                 = ImPlotLineFlags(1 << 10) // a line segment will be rendered from every two consecutive points
	ImPlotLineFlags_Loop                     = ImPlotLineFlags(1 << 11) // the last and first point will be connected to form a closed loop
	ImPlotLineFlags_SkipNaN                  = ImPlotLineFlags(1 << 12) // NaNs values will be skipped instead of rendered as missing data
	ImPlotLineFlags_NoClip                   = ImPlotLineFlags(1 << 13) // markers (if displayed) on the edge of a plot will not be clipped
	ImPlotLineFlags_Shaded                   = ImPlotLineFlags(1 << 14) // a filled region between the line and horizontal origin will be rendered; use PlotShaded for more advanced cases
	ImPlotLineFlags_AUTO     ImPlotLineFlags = -1                       // auto value
)

type ImPlotScatterFlags int

const (
	ImPlotScatterFlags_None                      = ImPlotScatterFlags(0)       // default
	ImPlotScatterFlags_NoClip                    = ImPlotScatterFlags(1 << 10) // markers on the edge of a plot will not be clipped
	ImPlotScatterFlags_AUTO   ImPlotScatterFlags = -1                          // auto value
)

type ImPlotStairsFlags int

const (
	ImPlotStairsFlags_None                      = ImPlotStairsFlags(0)       // default
	ImPlotStairsFlags_PreStep                   = ImPlotStairsFlags(1 << 10) // the y value is continued constantly to the left from every x position, i.e. the interval (x[i-1], x[i]] has the value y[i]
	ImPlotStairsFlags_Shaded                    = ImPlotStairsFlags(1 << 11)
	ImPlotStairsFlags_AUTO    ImPlotStairsFlags = -1 // auto value
)

type ImPlotShadedFlags int

const (
	ImPlotShadedFlags_None                   = ImPlotShadedFlags(0)
	ImPlotShadedFlags_AUTO ImPlotShadedFlags = -1 // auto value
)

type ImPlotBarsFlags int

const (
	ImPlotBarsFlags_None                       = ImPlotBarsFlags(0)       // default
	ImPlotBarsFlags_Horizontal                 = ImPlotBarsFlags(1 << 10) // bars will be rendered horizontally on the current y-axis
	ImPlotBarsFlags_AUTO       ImPlotBarsFlags = -1                       // auto value
)

type ImPlotBarGroupsFlags int

const (
	ImPlotBarGroupsFlags_None                            = ImPlotBarGroupsFlags(0)       // default
	ImPlotBarGroupsFlags_Horizontal                      = ImPlotBarGroupsFlags(1 << 10) // bar groups will be rendered horizontally on the current y-axis
	ImPlotBarGroupsFlags_Stacked                         = ImPlotBarGroupsFlags(1 << 11) // items in a group will be stacked on top of each other
	ImPlotBarGroupsFlags_AUTO       ImPlotBarGroupsFlags = -1                            // auto value
)

type ImPlotErrorBarsFlags int

const (
	ImPlotErrorBarsFlags_None                            = ImPlotErrorBarsFlags(0)       // default
	ImPlotErrorBarsFlags_Horizontal                      = ImPlotErrorBarsFlags(1 << 10) // error bars will be rendered horizontally on the current y-axis
	ImPlotErrorBarsFlags_AUTO       ImPlotErrorBarsFlags = -1                            // auto value
)

type ImPlotStemsFlags int

const (
	ImPlotStemsFlags_None                        = ImPlotStemsFlags(0)       // default
	ImPlotStemsFlags_Horizontal                  = ImPlotStemsFlags(1 << 10) // stems will be rendered horizontally on the current y-axis
	ImPlotStemsFlags_AUTO       ImPlotStemsFlags = -1                        // auto value
)

type ImPlotInfLinesFlags int

const (
	ImPlotInfLinesFlags_None                           = ImPlotInfLinesFlags(0) // default
	ImPlotInfLinesFlags_Horizontal                     = ImPlotInfLinesFlags(1 << 10)
	ImPlotInfLinesFlags_AUTO       ImPlotInfLinesFlags = -1 // auto value
)

type ImPlotPieChartFlags int

const (
	ImPlotPieChartFlags_None                             = ImPlotPieChartFlags(0)       // default
	ImPlotPieChartFlags_Normalize                        = ImPlotPieChartFlags(1 << 10) // force normalization of pie chart values (i.e. always make a full circle if sum < 0)
	ImPlotPieChartFlags_IgnoreHidden                     = ImPlotPieChartFlags(1 << 11)
	ImPlotPieChartFlags_AUTO         ImPlotPieChartFlags = -1 // auto value
)

type ImPlotHeatmapFlags int

const (
	ImPlotHeatmapFlags_None                        = ImPlotHeatmapFlags(0)       // default
	ImPlotHeatmapFlags_ColMajor                    = ImPlotHeatmapFlags(1 << 10) // data will be read in column major order
	ImPlotHeatmapFlags_AUTO     ImPlotHeatmapFlags = -1                          // auto value
)

type ImPlotHistogramFlags int

const (
	ImPlotHistogramFlags_None                            = ImPlotHistogramFlags(0)       // default
	ImPlotHistogramFlags_Horizontal                      = ImPlotHistogramFlags(1 << 10) // histogram bars will be rendered horizontally (not supported by PlotHistogram2D)
	ImPlotHistogramFlags_Cumulative                      = ImPlotHistogramFlags(1 << 11) // each bin will contain its count plus the counts of all previous bins (not supported by PlotHistogram2D)
	ImPlotHistogramFlags_Density                         = ImPlotHistogramFlags(1 << 12) // counts will be normalized, i.e. the PDF will be visualized, or the CDF will be visualized if Cumulative is also set
	ImPlotHistogramFlags_NoOutliers                      = ImPlotHistogramFlags(1 << 13) // exclude values outside the specifed histogram range from the count toward normalizing and cumulative counts
	ImPlotHistogramFlags_ColMajor                        = ImPlotHistogramFlags(1 << 14)
	ImPlotHistogramFlags_AUTO       ImPlotHistogramFlags = -1 // auto value
)

type ImPlotDigitalFlags int

const (
	ImPlotDigitalFlags_None                    = ImPlotDigitalFlags(0)
	ImPlotDigitalFlags_AUTO ImPlotDigitalFlags = -1 // auto value
)

type ImPlotImageFlags int

const (
	ImPlotImageFlags_None                  = ImPlotImageFlags(0)
	ImPlotImageFlags_AUTO ImPlotImageFlags = -1 // auto value
)

type ImPlotTextFlags int

const (
	ImPlotTextFlags_None                     = ImPlotTextFlags(0) // default
	ImPlotTextFlags_Vertical                 = ImPlotTextFlags(1 << 10)
	ImPlotTextFlags_AUTO     ImPlotTextFlags = -1 // auto value
)

type ImPlotDummyFlags int

const (
	ImPlotDummyFlags_None                  = ImPlotDummyFlags(0)
	ImPlotDummyFlags_AUTO ImPlotDummyFlags = -1 // auto value
)

type ImPlotCond int

const (
	ImPlotCond_None              = ImPlotCond(imgui.ImGuiCond_None)   // No condition (always set the variable), same as _Always
	ImPlotCond_Always            = ImPlotCond(imgui.ImGuiCond_Always) // No condition (always set the variable)
	ImPlotCond_Once              = ImPlotCond(imgui.ImGuiCond_Once)   // Set the variable once per runtime session (only the first call will succeed)
	ImPlotCond_AUTO   ImPlotCond = -1                           // auto value
)

type ImPlotCol int

const (
	ImPlotCol_Line                    = iota // plot line/outline color (defaults to next unused color in current colormap)
	ImPlotCol_Fill                    = iota // plot fill color for bars (defaults to the current line color)
	ImPlotCol_MarkerOutline           = iota // marker outline color (defaults to the current line color)
	ImPlotCol_MarkerFill              = iota // marker fill color (defaults to the current line color)
	ImPlotCol_ErrorBar                = iota // error bar color (defaults to imgui.ImGuiCol_Text)
	ImPlotCol_FrameBg                 = iota // plot frame background color (defaults to imgui.ImGuiCol_FrameBg)
	ImPlotCol_PlotBg                  = iota // plot area background color (defaults to imgui.ImGuiCol_WindowBg)
	ImPlotCol_PlotBorder              = iota // plot area border color (defaults to imgui.ImGuiCol_Border)
	ImPlotCol_LegendBg                = iota // legend background color (defaults to imgui.ImGuiCol_PopupBg)
	ImPlotCol_LegendBorder            = iota // legend border color (defaults to ImPlotCol_PlotBorder)
	ImPlotCol_LegendText              = iota // legend text color (defaults to ImPlotCol_InlayText)
	ImPlotCol_TitleText               = iota // plot title text color (defaults to imgui.ImGuiCol_Text)
	ImPlotCol_InlayText               = iota // color of text appearing inside of plots (defaults to imgui.ImGuiCol_Text)
	ImPlotCol_AxisText                = iota // axis label and tick lables color (defaults to imgui.ImGuiCol_Text)
	ImPlotCol_AxisGrid                = iota // axis grid color (defaults to 25% ImPlotCol_AxisText)
	ImPlotCol_AxisTick                = iota // axis tick color (defaults to AxisGrid)
	ImPlotCol_AxisBg                  = iota // background color of axis hover region (defaults to transparent)
	ImPlotCol_AxisBgHovered           = iota // axis hover color (defaults to imgui.ImGuiCol_ButtonHovered)
	ImPlotCol_AxisBgActive            = iota // axis active color (defaults to imgui.ImGuiCol_ButtonActive)
	ImPlotCol_Selection               = iota // box-selection color (defaults to yellow)
	ImPlotCol_Crosshairs              = iota // crosshairs color (defaults to ImPlotCol_PlotBorder)
	ImPlotCol_COUNT                   = iota
	ImPlotCol_AUTO          ImPlotCol = -1 // auto value
)

type ImPlotStyleVar int

const (
	ImPlotStyleVar_LineWeight                        = iota // float, plot item line weight in pixels
	ImPlotStyleVar_Marker                            = iota // int, marker specification
	ImPlotStyleVar_MarkerSize                        = iota // float, marker size in pixels (roughly the marker's "radius")
	ImPlotStyleVar_MarkerWeight                      = iota // float, plot outline weight of markers in pixels
	ImPlotStyleVar_FillAlpha                         = iota // float, alpha modifier applied to all plot item fills
	ImPlotStyleVar_ErrorBarSize                      = iota // float, error bar whisker width in pixels
	ImPlotStyleVar_ErrorBarWeight                    = iota // float, error bar whisker weight in pixels
	ImPlotStyleVar_DigitalBitHeight                  = iota // float, digital channels bit height (at 1) in pixels
	ImPlotStyleVar_DigitalBitGap                     = iota // float, digital channels bit padding gap in pixels
	ImPlotStyleVar_PlotBorderSize                    = iota // float, thickness of border around plot area
	ImPlotStyleVar_MinorAlpha                        = iota // float, alpha multiplier applied to minor axis grid lines
	ImPlotStyleVar_MajorTickLen                      = iota // imgui.ImVec2, major tick lengths for X and Y axes
	ImPlotStyleVar_MinorTickLen                      = iota // imgui.ImVec2, minor tick lengths for X and Y axes
	ImPlotStyleVar_MajorTickSize                     = iota // imgui.ImVec2, line thickness of major ticks
	ImPlotStyleVar_MinorTickSize                     = iota // imgui.ImVec2, line thickness of minor ticks
	ImPlotStyleVar_MajorGridSize                     = iota // imgui.ImVec2, line thickness of major grid lines
	ImPlotStyleVar_MinorGridSize                     = iota // imgui.ImVec2, line thickness of minor grid lines
	ImPlotStyleVar_PlotPadding                       = iota // imgui.ImVec2, padding between widget frame and plot area, labels, or outside legends (i.e. main padding)
	ImPlotStyleVar_LabelPadding                      = iota // imgui.ImVec2, padding between axes labels, tick labels, and plot edge
	ImPlotStyleVar_LegendPadding                     = iota // imgui.ImVec2, legend padding from plot edges
	ImPlotStyleVar_LegendInnerPadding                = iota // imgui.ImVec2, legend inner padding from legend edges
	ImPlotStyleVar_LegendSpacing                     = iota // imgui.ImVec2, spacing between legend entries
	ImPlotStyleVar_MousePosPadding                   = iota // imgui.ImVec2, padding between plot edge and interior info text
	ImPlotStyleVar_AnnotationPadding                 = iota // imgui.ImVec2, text padding around annotation labels
	ImPlotStyleVar_FitPadding                        = iota // imgui.ImVec2, additional fit padding as a percentage of the fit extents (e.g. imgui.ImVec2(0.1f,0.1f) adds 10% to the fit extents of X and Y)
	ImPlotStyleVar_PlotDefaultSize                   = iota // imgui.ImVec2, default size used when imgui.ImVec2(0,0) is passed to BeginPlot
	ImPlotStyleVar_PlotMinSize                       = iota // imgui.ImVec2, minimum size plot frame can be when shrunk
	ImPlotStyleVar_COUNT                             = iota
	ImPlotStyleVar_AUTO               ImPlotStyleVar = -1 // auto value
)

type ImPlotScale int

const (
	ImPlotScale_Linear             = ImPlotScale(0) // default linear scale
	ImPlotScale_Time               = iota           // date/time scale
	ImPlotScale_Log10              = iota           // base 10 logartithmic scale
	ImPlotScale_SymLog             = iota           // symmetric log scale
	ImPlotScale_AUTO   ImPlotScale = -1             // auto value
)

type ImPlotColormap int

const (
	ImPlotColormap_Deep                    = ImPlotColormap(0)  // a.k.a. seaborn deep (qual=true, n=10) (default)
	ImPlotColormap_Dark                    = ImPlotColormap(1)  // a.k.a. matplotlib "Set1" (qual=true, n=9 )
	ImPlotColormap_Pastel                  = ImPlotColormap(2)  // a.k.a. matplotlib "Pastel1" (qual=true, n=9 )
	ImPlotColormap_Paired                  = ImPlotColormap(3)  // a.k.a. matplotlib "Paired" (qual=true, n=12)
	ImPlotColormap_Viridis                 = ImPlotColormap(4)  // a.k.a. matplotlib "viridis" (qual=false, n=11)
	ImPlotColormap_Plasma                  = ImPlotColormap(5)  // a.k.a. matplotlib "plasma" (qual=false, n=11)
	ImPlotColormap_Hot                     = ImPlotColormap(6)  // a.k.a. matplotlib/MATLAB "hot" (qual=false, n=11)
	ImPlotColormap_Cool                    = ImPlotColormap(7)  // a.k.a. matplotlib/MATLAB "cool" (qual=false, n=11)
	ImPlotColormap_Pink                    = ImPlotColormap(8)  // a.k.a. matplotlib/MATLAB "pink" (qual=false, n=11)
	ImPlotColormap_Jet                     = ImPlotColormap(9)  // a.k.a. MATLAB "jet" (qual=false, n=11)
	ImPlotColormap_Twilight                = ImPlotColormap(10) // a.k.a. matplotlib "twilight" (qual=false, n=11)
	ImPlotColormap_RdBu                    = ImPlotColormap(11) // red/blue, Color Brewer (qual=false, n=11)
	ImPlotColormap_BrBG                    = ImPlotColormap(12) // brown/blue-green, Color Brewer (qual=false, n=11)
	ImPlotColormap_PiYG                    = ImPlotColormap(13) // pink/yellow-green, Color Brewer (qual=false, n=11)
	ImPlotColormap_Spectral                = ImPlotColormap(14) // color spectrum, Color Brewer (qual=false, n=11)
	ImPlotColormap_Greys                   = ImPlotColormap(15) // white/black (qual=false, n=2 )
	ImPlotColormap_AUTO     ImPlotColormap = -1                 // auto value
)

type ImPlotLocation int

const (
	ImPlotLocation_Center                   = ImPlotLocation(0)                                          // center-center
	ImPlotLocation_North                    = ImPlotLocation(1 << 0)                                     // top-center
	ImPlotLocation_South                    = ImPlotLocation(1 << 1)                                     // bottom-center
	ImPlotLocation_West                     = ImPlotLocation(1 << 2)                                     // center-left
	ImPlotLocation_East                     = ImPlotLocation(1 << 3)                                     // center-right
	ImPlotLocation_NorthWest                = ImPlotLocation(ImPlotLocation_North | ImPlotLocation_West) // top-left
	ImPlotLocation_NorthEast                = ImPlotLocation(ImPlotLocation_North | ImPlotLocation_East) // top-right
	ImPlotLocation_SouthWest                = ImPlotLocation(ImPlotLocation_South | ImPlotLocation_West) // bottom-left
	ImPlotLocation_SouthEast                = ImPlotLocation(ImPlotLocation_South | ImPlotLocation_East)
	ImPlotLocation_AUTO      ImPlotLocation = -1 // auto value
)

type ImPlotBin int

const (
	ImPlotBin_Sqrt              = ImPlotBin(-1) // k = sqrt(n)
	ImPlotBin_Sturges           = ImPlotBin(-2) // k = 1 + log2(n)
	ImPlotBin_Rice              = ImPlotBin(-3) // k = 2 * cbrt(n)
	ImPlotBin_Scott             = ImPlotBin(-4) // w = 3.49 * sigma / cbrt(n)
	ImPlotBin_AUTO    ImPlotBin = -1            // auto value
)

type ImPlotFlagsObsolete int

const (
	ImPlotFlags_YAxis2                           = ImPlotFlagsObsolete(1 << 20)
	ImPlotFlags_YAxis3                           = ImPlotFlagsObsolete(1 << 21)
	ImPlotFlagsObsolete_AUTO ImPlotFlagsObsolete = -1 // auto value
)
// -- deactivated -- // //go:build fffi_idl_code
// -- deactivated -- // package implot

// -- deactivated -- // import . "github.com/stergiotis/boxer/public/imzero/imgui"

var _ = imgui.ImVec2(0)

// GetStyleColorName Returns the null terminated string name for an ImPlotCol.
//foreign code:
//  auto r = ImPlot::GetStyleColorName(col)
func GetStyleColorName(col ImPlotCol) (r string) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000003ec)
	runtime.AddIntArg(_f, col)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetStringRetr[string](_f))
	return
}

// GetMarkerName Returns the null terminated string name for an ImPlotMarker.
//foreign code:
//  auto r = ImPlot::GetMarkerName(marker)
func GetMarkerName(marker ImPlotMarker) (r string) {
	_f := currentFffiVar
	_f.AddFunctionId(0x000003ed)
	runtime.AddIntArg(_f, marker)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetStringRetr[string](_f))

	return
}

// GetAutoColor Returns the automatically deduced style color.
//foreign code:
//  auto r = ImPlot::GetAutoColor(idx)
func GetAutoColor(idx ImPlotCol) (r imgui.ImVec4) {
	_f := currentFffiVar
	_f.AddFunctionId(0x000003ee)
	runtime.AddIntArg(_f, idx)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = imgui.ImVec4(runtime.GetFloat32Array4Retr[float32](_f))

	return
}

// NiceNum Rounds x to powers of 2,5 and 10 for generating axis labels (from Graphics Gems 1 Chapter 11.2)
//foreign code:
//  auto r = ImPlot::NiceNum(x, round)
func NiceNum(x float64, round bool) (r float64) {
	_f := currentFffiVar
	_f.AddFunctionId(0x000003ef)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddBoolArg(_f, round)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))

	return
}

// BustPlotCache Busts the cache for every plot in the current context.
//foreign code:
//  ImPlot::BustPlotCache()
func BustPlotCache() {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003f0)
	_f.CallProcedure()

}

// SetupAxis Enables an axis or sets the label and/or flags for an existing axis. Leave label = nullptr for no label.The following API allows you to setup and customize various aspects of the current plot. The functions should be called immediately after BeginPlot and before any other API calls. Typical usage is as follows: if (BeginPlot(...)) { 1) begin a new plot SetupAxis(ImAxis_X1, "My X-Axis"); 2) make Setup calls SetupAxis(ImAxis_Y1, "My Y-Axis"); SetupLegend(ImPlotLocation_North); ... SetupFinish(); 3) [optional] explicitly finish setup PlotLine(...); 4) plot items ... EndPlot(); 5) end the plot } Important notes: Always call Setup code at the top of your BeginPlot conditional statement. Setup is locked once you start plotting or explicitly call SetupFinish. Do NOT call Setup code after you begin plotting or after you make any non-Setup API calls (e.g. utils like PlotToPixels also lock Setup) Calling SetupFinish is OPTIONAL, but probably good practice. If you do not call it yourself, then the first subsequent plotting or utility function will call it for you.
//foreign code:
//  ImPlot::SetupAxis(axis)
func SetupAxis(axis ImAxis) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003f1)
	runtime.AddIntArg(_f, axis)
	_f.CallProcedure()

}

// SetupAxisV Enables an axis or sets the label and/or flags for an existing axis. Leave label = nullptr for no label.The following API allows you to setup and customize various aspects of the current plot. The functions should be called immediately after BeginPlot and before any other API calls. Typical usage is as follows: if (BeginPlot(...)) { 1) begin a new plot SetupAxis(ImAxis_X1, "My X-Axis"); 2) make Setup calls SetupAxis(ImAxis_Y1, "My Y-Axis"); SetupLegend(ImPlotLocation_North); ... SetupFinish(); 3) [optional] explicitly finish setup PlotLine(...); 4) plot items ... EndPlot(); 5) end the plot } Important notes: Always call Setup code at the top of your BeginPlot conditional statement. Setup is locked once you start plotting or explicitly call SetupFinish. Do NOT call Setup code after you begin plotting or after you make any non-Setup API calls (e.g. utils like PlotToPixels also lock Setup) Calling SetupFinish is OPTIONAL, but probably good practice. If you do not call it yourself, then the first subsequent plotting or utility function will call it for you.
// * label const char * = nullptr
// * flags ImPlotAxisFlags = 0
//foreign code:
//  ImPlot::SetupAxis(axis, label, flags)
func SetupAxisV(axis ImAxis, label string /* = nullptr*/, flags ImPlotAxisFlags /* = 0*/) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003f2)
	runtime.AddIntArg(_f, axis)
	runtime.AddStringArg(_f, label)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}

// SetupAxisLimits Sets an axis range limits. If ImPlotCond_Always is used, the axes limits will be locked. Inversion with v_min > v_max is not supported; use SetupAxisLimits instead.
//foreign code:
//  ImPlot::SetupAxisLimits(idx, min_lim, max_lim, cond)
func SetupAxisLimits(idx ImAxis, min_lim float64, max_lim float64, cond ImPlotCond) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003f3)
	runtime.AddIntArg(_f, idx)
	runtime.AddFloat64Arg(_f, min_lim)
	runtime.AddFloat64Arg(_f, max_lim)
	runtime.AddIntArg(_f, cond)
	_f.CallProcedure()

}

// SetupAxisFormat Sets the format of numeric axis labels via formater specifier (default="%g"). Formated values will be double (i.e. use f).
//foreign code:
//  ImPlot::SetupAxisFormat(idx, fmt)
func SetupAxisFormat(idx ImAxis, fmt string) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003f4)
	runtime.AddIntArg(_f, idx)
	runtime.AddStringArg(_f, fmt)
	_f.CallProcedure()

}

// SetupAxisScale Sets an axis' scale using built-in options.
//foreign code:
//  ImPlot::SetupAxisScale(idx, scale)
func SetupAxisScale(idx ImAxis, scale ImPlotScale) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003f5)
	runtime.AddIntArg(_f, idx)
	runtime.AddIntArg(_f, scale)
	_f.CallProcedure()

}

// SetupAxisLimitsConstraints Sets an axis' limits constraints.
//foreign code:
//  ImPlot::SetupAxisLimitsConstraints(idx, v_min, v_max)
func SetupAxisLimitsConstraints(idx ImAxis, v_min float64, v_max float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003f6)
	runtime.AddIntArg(_f, idx)
	runtime.AddFloat64Arg(_f, v_min)
	runtime.AddFloat64Arg(_f, v_max)
	_f.CallProcedure()

}

// SetupAxisZoomConstraints Sets an axis' zoom constraints.
//foreign code:
//  ImPlot::SetupAxisZoomConstraints(idx, z_min, z_max)
func SetupAxisZoomConstraints(idx ImAxis, z_min float64, z_max float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003f7)
	runtime.AddIntArg(_f, idx)
	runtime.AddFloat64Arg(_f, z_min)
	runtime.AddFloat64Arg(_f, z_max)
	_f.CallProcedure()

}

// SetupAxes Sets the label and/or flags for primary X and Y axes (shorthand for two calls to SetupAxis).
//foreign code:
//  ImPlot::SetupAxes(x_label, y_label, x_flags, y_flags)
func SetupAxes(x_label string, y_label string, x_flags ImPlotAxisFlags, y_flags ImPlotAxisFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003f8)
	runtime.AddStringArg(_f, x_label)
	runtime.AddStringArg(_f, y_label)
	runtime.AddIntArg(_f, x_flags)
	runtime.AddIntArg(_f, y_flags)
	_f.CallProcedure()

}

// SetupAxesLimits Sets the primary X and Y axes range limits. If ImPlotCond_Always is used, the axes limits will be locked (shorthand for two calls to SetupAxisLimits).
//foreign code:
//  ImPlot::SetupAxesLimits(x_min, x_max, y_min, y_max, cond)
func SetupAxesLimits(x_min float64, x_max float64, y_min float64, y_max float64, cond ImPlotCond) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003f9)
	runtime.AddFloat64Arg(_f, x_min)
	runtime.AddFloat64Arg(_f, x_max)
	runtime.AddFloat64Arg(_f, y_min)
	runtime.AddFloat64Arg(_f, y_max)
	runtime.AddIntArg(_f, cond)
	_f.CallProcedure()

}

// SetupLegend Sets up the plot legend. This can also be called immediately after BeginSubplots when using ImPlotSubplotFlags_ShareItems.
//foreign code:
//  ImPlot::SetupLegend(location, flags)
func SetupLegend(location ImPlotLocation, flags ImPlotLegendFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003fa)
	runtime.AddIntArg(_f, location)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}

// SetupMouseText Set the location of the current plot's mouse position text (default = South|East).
//foreign code:
//  ImPlot::SetupMouseText(location, flags)
func SetupMouseText(location ImPlotLocation, flags ImPlotMouseTextFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003fb)
	runtime.AddIntArg(_f, location)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}

// SetNextAxisLimits Sets an upcoming axis range limits. If ImPlotCond_Always is used, the axes limits will be locked.Though you should default to the Setup API above, there are some scenarios where (re)configuring a plot or axis before BeginPlot is needed (e.g. if using a preceding button or slider widget to change the plot limits). In this case, you can use the SetNext API below. While this is not as feature rich as the Setup API, most common needs are provided. These functions can be called anwhere except for inside of Begin/EndPlot. For example: if (ImGui::Button("Center Plot")) ImPlot::SetNextPlotLimits(-1,1,-1,1); if (ImPlot::BeginPlot(...)) { ... ImPlot::EndPlot(); } Important notes: You must still enable non-default axes with SetupAxis for these functions to work properly.
//foreign code:
//  ImPlot::SetNextAxisLimits(axis, v_min, v_max)
func SetNextAxisLimits(axis ImAxis, v_min float64, v_max float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003fc)
	runtime.AddIntArg(_f, axis)
	runtime.AddFloat64Arg(_f, v_min)
	runtime.AddFloat64Arg(_f, v_max)
	_f.CallProcedure()

}

// SetNextAxisLimitsV Sets an upcoming axis range limits. If ImPlotCond_Always is used, the axes limits will be locked.Though you should default to the Setup API above, there are some scenarios where (re)configuring a plot or axis before BeginPlot is needed (e.g. if using a preceding button or slider widget to change the plot limits). In this case, you can use the SetNext API below. While this is not as feature rich as the Setup API, most common needs are provided. These functions can be called anwhere except for inside of Begin/EndPlot. For example: if (ImGui::Button("Center Plot")) ImPlot::SetNextPlotLimits(-1,1,-1,1); if (ImPlot::BeginPlot(...)) { ... ImPlot::EndPlot(); } Important notes: You must still enable non-default axes with SetupAxis for these functions to work properly.
// * cond ImPlotCond = ImPlotCond_Once
//foreign code:
//  ImPlot::SetNextAxisLimits(axis, v_min, v_max, cond)
func SetNextAxisLimitsV(axis ImAxis, v_min float64, v_max float64, cond ImPlotCond /* = ImPlotCond_Once*/) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003fd)
	runtime.AddIntArg(_f, axis)
	runtime.AddFloat64Arg(_f, v_min)
	runtime.AddFloat64Arg(_f, v_max)
	runtime.AddIntArg(_f, cond)
	_f.CallProcedure()

}

// SetNextAxisToFit Set an upcoming axis to auto fit to its data.
//foreign code:
//  ImPlot::SetNextAxisToFit(axis)
func SetNextAxisToFit(axis ImAxis) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003fe)
	runtime.AddIntArg(_f, axis)
	_f.CallProcedure()

}

// SetNextAxesLimits Sets the upcoming primary X and Y axes range limits. If ImPlotCond_Always is used, the axes limits will be locked (shorthand for two calls to SetupAxisLimits).
//foreign code:
//  ImPlot::SetNextAxesLimits(x_min, x_max, y_min, y_max, cond)
func SetNextAxesLimits(x_min float64, x_max float64, y_min float64, y_max float64, cond ImPlotCond) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000003ff)
	runtime.AddFloat64Arg(_f, x_min)
	runtime.AddFloat64Arg(_f, x_max)
	runtime.AddFloat64Arg(_f, y_min)
	runtime.AddFloat64Arg(_f, y_max)
	runtime.AddIntArg(_f, cond)
	_f.CallProcedure()

}

// SetNextAxesToFit Sets all upcoming axes to auto fit to their data.
//foreign code:
//  ImPlot::SetNextAxesToFit()
func SetNextAxesToFit() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000400)
	_f.CallProcedure()

}

// BeginPlot Starts a 2D plotting context. If this function returns true, EndPlot() MUST be called! You are encouraged to use the following convention: if (BeginPlot(...)) { PlotLine(...); ... EndPlot(); } Important notes: title_id must be unique to the current imgui.ImGui ID scope. If you need to avoid ID collisions or don't want to display a title in the plot, use double hashes (e.g. "MyPlot##HiddenIdText" or "##NoTitle"). size is the frame size of the plot widget, not the plot area. The default size of plots (i.e. when imgui.ImVec2(0,0)) can be modified in your ImPlotStyle.
//foreign code:
//  auto r = ImPlot::BeginPlot(title_id)
func BeginPlot(title_id string) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000401)
	runtime.AddStringArg(_f, title_id)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// BeginPlotV Starts a 2D plotting context. If this function returns true, EndPlot() MUST be called! You are encouraged to use the following convention: if (BeginPlot(...)) { PlotLine(...); ... EndPlot(); } Important notes: title_id must be unique to the current imgui.ImGui ID scope. If you need to avoid ID collisions or don't want to display a title in the plot, use double hashes (e.g. "MyPlot##HiddenIdText" or "##NoTitle"). size is the frame size of the plot widget, not the plot area. The default size of plots (i.e. when imgui.ImVec2(0,0)) can be modified in your ImPlotStyle.
// * size const imgui.ImVec2 & = imgui.ImVec2(-1, 0)
// * flags ImPlotFlags = 0
//foreign code:
//  auto r = ImPlot::BeginPlot(title_id, size, flags)
func BeginPlotV(title_id string, size imgui.ImVec2 /* = imgui.ImVec2(-1, 0)*/, flags ImPlotFlags /* = 0*/) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000402)
	runtime.AddStringArg(_f, title_id)
	runtime.AddComplex64Arg(_f, size)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// SetupFinish Explicitly finalize plot setup. Once you call this, you cannot make anymore Setup calls for the current plot! Note that calling this function is OPTIONAL; it will be called by the first subsequent setup-locking API call.
//foreign code:
//  ImPlot::SetupFinish()
func SetupFinish() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000403)
	_f.CallProcedure()

}

// EndPlot Only call EndPlot() if BeginPlot() returns true! Typically called at the end of an if statement conditioned on BeginPlot(). See example above.
//foreign code:
//  ImPlot::EndPlot()
func EndPlot() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000404)
	_f.CallProcedure()

}

// SubplotNextCell Advances to next subplot.
//foreign code:
//  ImPlot::SubplotNextCell()
func SubplotNextCell() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000405)
	_f.CallProcedure()

}

// BeginSubplots -|--|-Starts a subdivided plotting context. If the function returns true, EndSubplots() MUST be called! Call BeginPlot/EndPlot AT MOST [rows*cols] times in between the begining and end of the subplot context. Plots are added in row major order. Example: if (BeginSubplots("My Subplot",2,3,ImVec2(800,400)) { for (int i = 0; i < 6; ++i) { if (BeginPlot(...)) { ImPlot::PlotLine(...); ... EndPlot(); } } EndSubplots(); } Produces: Important notes: title_id must be unique to the current imgui.ImGui ID scope. If you need to avoid ID collisions or don't want to display a title in the plot, use double hashes (e.g. "MySubplot##HiddenIdText" or "##NoTitle"). rows and cols must be greater than 0. size is the size of the entire grid of subplots, not the individual plots row_ratios and col_ratios must have AT LEAST rows and cols elements, respectively. These are the sizes of the rows and columns expressed in ratios. If the user adjusts the dimensions, the arrays are updated with new ratios. Important notes regarding BeginPlot from inside of BeginSubplots: The title_id parameter of BeginPlot (see above) does NOT have to be unique when called inside of a subplot context. Subplot IDs are hashed for your convenience so you don't have call PushID or generate unique title strings. Simply pass an empty string to BeginPlot unless you want to title each subplot. The size parameter of BeginPlot (see above) is ignored when inside of a subplot context. The actual size of the subplot will be based on the size value you pass to BeginSubplots and row/col_ratios if provided.
//foreign code:
//  auto r = ImPlot::BeginSubplots(title_id, rows, cols, size)
func BeginSubplots(title_id string, rows int, cols int, size imgui.ImVec2) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000406)
	runtime.AddStringArg(_f, title_id)
	runtime.AddIntArg(_f, rows)
	runtime.AddIntArg(_f, cols)
	runtime.AddComplex64Arg(_f, size)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// EndSubplots Only call EndSubplots() if BeginSubplots() returns true! Typically called at the end of an if statement conditioned on BeginSublots(). See example above.
//foreign code:
//  ImPlot::EndSubplots()
func EndSubplots() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000407)
	_f.CallProcedure()

}

// SetAxis Select which axis/axes will be used for subsequent plot elements.
//foreign code:
//  ImPlot::SetAxis(axis)
func SetAxis(axis ImAxis) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000408)
	runtime.AddIntArg(_f, axis)
	_f.CallProcedure()

}

func SetAxes(x_idx ImAxis, y_idx ImAxis) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000409)
	runtime.AddIntArg(_f, x_idx)
	runtime.AddIntArg(_f, y_idx)
	_f.CallProcedure()

}

func PixelsToPlot(x float32, y float32, x_idx ImAxis, y_idx ImAxis) (r ImPlotPoint) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000040a)
	runtime.AddFloat32Arg(_f, x)
	runtime.AddFloat32Arg(_f, y)
	runtime.AddIntArg(_f, x_idx)
	runtime.AddIntArg(_f, y_idx)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = ImPlotPoint(runtime.GetComplex128Retr[complex128](_f))

	return
}

// PixelsToPlot Convert pixels to a position in the current plot's coordinate system. Passing IMPLOT_AUTO uses the current axes.
//foreign code:
//  auto r = ImPlot::PixelsToPlot(pix, x_idx, y_idx)
func PixelsToPlotImVec2(pix imgui.ImVec2, x_idx ImAxis, y_idx ImAxis) (r ImPlotPoint) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000040b)
	runtime.AddComplex64Arg(_f, pix)
	runtime.AddIntArg(_f, x_idx)
	runtime.AddIntArg(_f, y_idx)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = ImPlotPoint(runtime.GetComplex128Retr[complex128](_f))

	return
}

func PlotToPixels(x float64, y float64, x_idx ImAxis, y_idx ImAxis) (r imgui.ImVec2) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000040c)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddIntArg(_f, x_idx)
	runtime.AddIntArg(_f, y_idx)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = imgui.ImVec2(runtime.GetComplex64Retr[complex64](_f))

	return
}

// PlotToPixels Convert a position in the current plot's coordinate system to pixels. Passing IMPLOT_AUTO uses the current axes.
//foreign code:
//  auto r = ImPlot::PlotToPixels(plt, x_idx, y_idx)
func PlotToPixelsImPlotPoint(plt ImPlotPoint, x_idx ImAxis, y_idx ImAxis) (r imgui.ImVec2) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000040d)
	runtime.AddComplex128Arg(_f, plt)
	runtime.AddIntArg(_f, x_idx)
	runtime.AddIntArg(_f, y_idx)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = imgui.ImVec2(runtime.GetComplex64Retr[complex64](_f))

	return
}

// GetPlotPos Get the current Plot position (top-left) in pixels.
//foreign code:
//  auto r = ImPlot::GetPlotPos()
func GetPlotPos() (r imgui.ImVec2) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000040e)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = imgui.ImVec2(runtime.GetComplex64Retr[complex64](_f))

	return
}

// GetPlotSize Get the curent Plot size in pixels.
//foreign code:
//  auto r = ImPlot::GetPlotSize()
func GetPlotSize() (r imgui.ImVec2) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000040f)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = imgui.ImVec2(runtime.GetComplex64Retr[complex64](_f))

	return
}

// GetPlotMousePos Returns the mouse position in x,y coordinates of the current plot. Passing IMPLOT_AUTO uses the current axes.
//foreign code:
//  auto r = ImPlot::GetPlotMousePos(x_idx, y_idx)
func GetPlotMousePos(x_idx ImAxis, y_idx ImAxis) (r ImPlotPoint) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000410)
	runtime.AddIntArg(_f, x_idx)
	runtime.AddIntArg(_f, y_idx)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = ImPlotPoint(runtime.GetComplex128Retr[complex128](_f))

	return
}

// IsPlotHovered Returns true if the plot area in the current plot is hovered.
//foreign code:
//  auto r = ImPlot::IsPlotHovered()
func IsPlotHovered() (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000411)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// IsAxisHovered Returns true if the axis label area in the current plot is hovered.
//foreign code:
//  auto r = ImPlot::IsAxisHovered(axis)
func IsAxisHovered(axis ImAxis) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000412)
	runtime.AddIntArg(_f, axis)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// IsSubplotsHovered Returns true if the bounding frame of a subplot is hovered.
//foreign code:
//  auto r = ImPlot::IsSubplotsHovered()
func IsSubplotsHovered() (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000413)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// IsPlotSelected Returns true if the current plot is being box selected.
//foreign code:
//  auto r = ImPlot::IsPlotSelected()
func IsPlotSelected() (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000414)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// CancelPlotSelection Cancels a the current plot box selection.
//foreign code:
//  ImPlot::CancelPlotSelection()
func CancelPlotSelection() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000415)
	_f.CallProcedure()

}

// HideNextItem Hides or shows the next plot item (i.e. as if it were toggled from the legend). Use ImPlotCond_Always if you need to forcefully set this every frame.
//foreign code:
//  ImPlot::HideNextItem()
func HideNextItem() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000416)
	_f.CallProcedure()

}

// HideNextItemV Hides or shows the next plot item (i.e. as if it were toggled from the legend). Use ImPlotCond_Always if you need to forcefully set this every frame.
// * hidden bool = true
// * cond ImPlotCond = ImPlotCond_Once
//foreign code:
//  ImPlot::HideNextItem(hidden, cond)
func HideNextItemV(hidden bool /* = true*/, cond ImPlotCond /* = ImPlotCond_Once*/) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000417)
	runtime.AddBoolArg(_f, hidden)
	runtime.AddIntArg(_f, cond)
	_f.CallProcedure()

}

// Annotation Shows an annotation callout at a chosen point. Clamping keeps annotations in the plot area. Annotations are always rendered on top.
//foreign code:
//  ImPlot::Annotation(x, y, col, offset, clamp, round)
func Annotation(x float64, y float64, col imgui.ImVec4, offset imgui.ImVec2, clamp bool, round bool) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000418)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat32Array4Arg(_f, col)
	runtime.AddComplex64Arg(_f, offset)
	runtime.AddBoolArg(_f, clamp)
	runtime.AddBoolArg(_f, round)
	_f.CallProcedure()

}

// TagX Shows a x-axis tag at the specified coordinate value.
//foreign code:
//  ImPlot::TagX(x, color, round)
func TagX(x float64, color imgui.ImVec4, round bool) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000419)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat32Array4Arg(_f, color)
	runtime.AddBoolArg(_f, round)
	_f.CallProcedure()

}

// TagY Shows a y-axis tag at the specified coordinate value.
//foreign code:
//  ImPlot::TagY(y, color, round)
func TagY(y float64, color imgui.ImVec4, round bool) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000041a)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat32Array4Arg(_f, color)
	runtime.AddBoolArg(_f, round)
	_f.CallProcedure()

}

// IsLegendEntryHovered Returns true if a plot item legend entry is hovered.
//foreign code:
//  auto r = ImPlot::IsLegendEntryHovered(label_id)
func IsLegendEntryHovered(label_id string) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000041b)
	runtime.AddStringArg(_f, label_id)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// BeginLegendPopup Begin a popup for a legend entry.
//foreign code:
//  auto r = ImPlot::BeginLegendPopup(label_id, mouse_button)
func BeginLegendPopup(label_id string, mouse_button imgui.ImGuiMouseButton) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000041c)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntArg(_f, mouse_button)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// EndLegendPopup End a popup for a legend entry.
//foreign code:
//  ImPlot::EndLegendPopup()
func EndLegendPopup() {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000041d)
	_f.CallProcedure()

}

// ShowAltLegend Shows an alternate legend for the plot identified by title_id, outside of the plot frame (can be called before or after of Begin/EndPlot but must occur in the same imgui.ImGui window! This is not thoroughly tested nor scrollable!).
//foreign code:
//  ImPlot::ShowAltLegend(title_id, vertical, size, interactable)
func ShowAltLegend(title_id string, vertical bool, size imgui.ImVec2, interactable bool) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000041e)
	runtime.AddStringArg(_f, title_id)
	runtime.AddBoolArg(_f, vertical)
	runtime.AddComplex64Arg(_f, size)
	runtime.AddBoolArg(_f, interactable)
	_f.CallProcedure()

}

// BeginDragDropTargetPlot Turns the current plot's plotting area into a drag and drop target. Don't forget to call EndDragDropTarget!
//foreign code:
//  auto r = ImPlot::BeginDragDropTargetPlot()
func BeginDragDropTargetPlot() (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000041f)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// BeginDragDropTargetAxis Turns the current plot's X-axis into a drag and drop target. Don't forget to call EndDragDropTarget!
//foreign code:
//  auto r = ImPlot::BeginDragDropTargetAxis(axis)
func BeginDragDropTargetAxis(axis ImAxis) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000420)
	runtime.AddIntArg(_f, axis)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// BeginDragDropTargetLegend Turns the current plot's legend into a drag and drop target. Don't forget to call EndDragDropTarget!
//foreign code:
//  auto r = ImPlot::BeginDragDropTargetLegend()
func BeginDragDropTargetLegend() (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000421)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// EndDragDropTarget Ends a drag and drop target (currently just an alias for imgui.ImGui::EndDragDropTarget).
//foreign code:
//  ImPlot::EndDragDropTarget()
func EndDragDropTarget() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000422)
	_f.CallProcedure()

}

// BeginDragDropSourcePlot Turns the current plot's plotting area into a drag and drop source. You must hold Ctrl. Don't forget to call EndDragDropSource!NB: By default, plot and axes drag and drop sources require holding the Ctrl modifier to initiate the drag. You can change the modifier if desired. If imgui.ImGuiMod_None is provided, the axes will be locked from panning.
//foreign code:
//  auto r = ImPlot::BeginDragDropSourcePlot()
func BeginDragDropSourcePlot() (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000423)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// BeginDragDropSourcePlotV Turns the current plot's plotting area into a drag and drop source. You must hold Ctrl. Don't forget to call EndDragDropSource!NB: By default, plot and axes drag and drop sources require holding the Ctrl modifier to initiate the drag. You can change the modifier if desired. If imgui.ImGuiMod_None is provided, the axes will be locked from panning.
// * flags imgui.ImGuiDragDropFlags = 0
//foreign code:
//  auto r = ImPlot::BeginDragDropSourcePlot(flags)
func BeginDragDropSourcePlotV(flags imgui.ImGuiDragDropFlags /* = 0*/) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000424)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// BeginDragDropSourceAxis Turns the current plot's X-axis into a drag and drop source. You must hold Ctrl. Don't forget to call EndDragDropSource!
//foreign code:
//  auto r = ImPlot::BeginDragDropSourceAxis(idx, flags)
func BeginDragDropSourceAxis(idx ImAxis, flags imgui.ImGuiDragDropFlags) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000425)
	runtime.AddIntArg(_f, idx)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// BeginDragDropSourceItem Turns an item in the current plot's legend into drag and drop source. Don't forget to call EndDragDropSource!
//foreign code:
//  auto r = ImPlot::BeginDragDropSourceItem(label_id, flags)
func BeginDragDropSourceItem(label_id string, flags imgui.ImGuiDragDropFlags) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000426)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// EndDragDropSource Ends a drag and drop source (currently just an alias for imgui.ImGui::EndDragDropSource).
//foreign code:
//  ImPlot::EndDragDropSource()
func EndDragDropSource() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000427)
	_f.CallProcedure()

}

// BeginAlignedPlots Use the following around calls to Begin/EndPlot to align l/r/t/b padding. Consider using Begin/EndSubplots first. They are more feature rich and accomplish the same behaviour by default. The functions below offer lower level control of plot alignment. Align axis padding over multiple plots in a single row or column. group_id must be unique. If this function returns true, EndAlignedPlots() must be called.
//foreign code:
//  auto r = ImPlot::BeginAlignedPlots(group_id)
func BeginAlignedPlots(group_id string) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000428)
	runtime.AddStringArg(_f, group_id)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// BeginAlignedPlotsV Use the following around calls to Begin/EndPlot to align l/r/t/b padding. Consider using Begin/EndSubplots first. They are more feature rich and accomplish the same behaviour by default. The functions below offer lower level control of plot alignment. Align axis padding over multiple plots in a single row or column. group_id must be unique. If this function returns true, EndAlignedPlots() must be called.
// * vertical bool = true
//foreign code:
//  auto r = ImPlot::BeginAlignedPlots(group_id, vertical)
func BeginAlignedPlotsV(group_id string, vertical bool /* = true*/) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000429)
	runtime.AddStringArg(_f, group_id)
	runtime.AddBoolArg(_f, vertical)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// EndAlignedPlots Only call EndAlignedPlots() if BeginAlignedPlots() returns true!
//foreign code:
//  ImPlot::EndAlignedPlots()
func EndAlignedPlots() {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000042a)
	_f.CallProcedure()

}

// PushStyleColor Temporarily modify a style color. Don't forget to call PopStyleColor!Use PushStyleX to temporarily modify your ImPlotStyle. The modification will last until the matching call to PopStyleX. You MUST call a pop for every push, otherwise you will leak memory! This behaves just like imgui.ImGui.
//foreign code:
//  ImPlot::PushStyleColor(idx, col)
func PushStyleColor(idx ImPlotCol, col uint32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000042b)
	runtime.AddIntArg(_f, idx)
	runtime.AddUint32Arg(_f, col)
	_f.CallProcedure()

}

func PushStyleColorImVec4(idx ImPlotCol, col imgui.ImVec4) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000042c)
	runtime.AddIntArg(_f, idx)
	runtime.AddFloat32Array4Arg(_f, col)
	_f.CallProcedure()

}

// PopStyleColor Undo temporary style color modification(s). Undo multiple pushes at once by increasing count.
//foreign code:
//  ImPlot::PopStyleColor(count)
func PopStyleColor(count int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000042d)
	runtime.AddIntArg(_f, count)
	_f.CallProcedure()

}

// PushStyleVar Temporarily modify a style variable of float type. Don't forget to call PopStyleVar!
//foreign code:
//  ImPlot::PushStyleVar(idx, val)
func PushStyleVar(idx ImPlotStyleVar, val float32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000042e)
	runtime.AddIntArg(_f, idx)
	runtime.AddFloat32Arg(_f, val)
	_f.CallProcedure()

}

// PushStyleVar Temporarily modify a style variable of int type. Don't forget to call PopStyleVar!
//foreign code:
//  ImPlot::PushStyleVar(idx, val)
func PushStyleVarInt(idx ImPlotStyleVar, val int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000042f)
	runtime.AddIntArg(_f, idx)
	runtime.AddIntArg(_f, val)
	_f.CallProcedure()

}

// PushStyleVar Temporarily modify a style variable of imgui.ImVec2 type. Don't forget to call PopStyleVar!
//foreign code:
//  ImPlot::PushStyleVar(idx, val)
func PushStyleVarImVec2(idx ImPlotStyleVar, val imgui.ImVec2) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000430)
	runtime.AddIntArg(_f, idx)
	runtime.AddComplex64Arg(_f, val)
	_f.CallProcedure()

}

// PopStyleVar Undo temporary style variable modification(s). Undo multiple pushes at once by increasing count.
//foreign code:
//  ImPlot::PopStyleVar(count)
func PopStyleVar(count int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000431)
	runtime.AddIntArg(_f, count)
	_f.CallProcedure()

}

// GetColormapCount Returns the number of available colormaps (i.e. the built-in + user-added count).
//foreign code:
//  auto r = ImPlot::GetColormapCount()
func GetColormapCount() (r int) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000432)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetIntRetr[int](_f))

	return
}

// GetColormapName Returns a null terminated string name for a colormap given an index. Returns nullptr if index is invalid.
//foreign code:
//  auto r = ImPlot::GetColormapName(colormap)
func GetColormapName(colormap ImPlotColormap) (r string) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000433)
	runtime.AddIntArg(_f, colormap)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetStringRetr[string](_f))

	return
}

// GetColormapIndex Returns an index number for a colormap given a valid string name. Returns -1 if name is invalid.
//foreign code:
//  auto r = ImPlot::GetColormapIndex(name)
func GetColormapIndex(name string) (r ImPlotColormap) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000434)
	runtime.AddStringArg(_f, name)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = ImPlotColormap(runtime.GetIntRetr[int](_f))

	return
}

// PushColormap Temporarily switch to one of the built-in (i.e. ImPlotColormap_XXX) or user-added colormaps (i.e. a return value of AddColormap). Don't forget to call PopColormap!
//foreign code:
//  ImPlot::PushColormap(colormap)
func PushColormapById(colormap ImPlotColormap) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000435)
	runtime.AddIntArg(_f, colormap)
	_f.CallProcedure()

}

// PushColormap Push a colormap by string name. Use built-in names such as "Default", "Deep", "Jet", etc. or a string you provided to AddColormap. Don't forget to call PopColormap!
//foreign code:
//  ImPlot::PushColormap(name)
func PushColormap(name string) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000436)
	runtime.AddStringArg(_f, name)
	_f.CallProcedure()

}

// PopColormap Undo temporary colormap modification(s). Undo multiple pushes at once by increasing count.
//foreign code:
//  ImPlot::PopColormap(count)
func PopColormap(count int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000437)
	runtime.AddIntArg(_f, count)
	_f.CallProcedure()

}

// NextColormapColorU32 Returns the next unused colormap color and advances the colormap. Can be used to skip colors if desired.
//foreign code:
//  auto r = ImPlot::NextColormapColorU32()
func NextColormapColorU32() (r uint32) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000438)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetUint32Retr[uint32](_f))

	return
}

// NextColormapColor Returns the next color from the current colormap and advances the colormap for the current plot. Can also be used with no return value to skip colors if desired. You need to call this between Begin/EndPlot!
//foreign code:
//  auto r = ImPlot::NextColormapColor()
func NextColormapColor() (r imgui.ImVec4) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000439)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = imgui.ImVec4(runtime.GetFloat32Array4Retr[float32](_f))

	return
}

// GetColormapSize Returns the size of a colormap.Colormap utils. If cmap = IMPLOT_AUTO (default), the current colormap is assumed. Pass an explicit colormap index (built-in or user-added) to specify otherwise.
//foreign code:
//  auto r = ImPlot::GetColormapSize()
func GetColormapSize() (r int) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000043a)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetIntRetr[int](_f))

	return
}

// GetColormapSizeV Returns the size of a colormap.Colormap utils. If cmap = IMPLOT_AUTO (default), the current colormap is assumed. Pass an explicit colormap index (built-in or user-added) to specify otherwise.
// * cmap ImPlotColormap = IMPLOT_AUTO
//foreign code:
//  auto r = ImPlot::GetColormapSize(cmap)
func GetColormapSizeV(cmap ImPlotColormap /* = IMPLOT_AUTO*/) (r int) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000043b)
	runtime.AddIntArg(_f, cmap)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetIntRetr[int](_f))

	return
}

// GetColormapColorU32 Returns a color from the Color map given an index >= 0 (modulo will be performed).
//foreign code:
//  auto r = ImPlot::GetColormapColorU32(idx, cmap)
func GetColormapColorU32(idx int, cmap ImPlotColormap) (r uint32) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000043c)
	runtime.AddIntArg(_f, idx)
	runtime.AddIntArg(_f, cmap)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetUint32Retr[uint32](_f))

	return
}

// GetColormapColor Returns a color from a colormap given an index >= 0 (modulo will be performed).
//foreign code:
//  auto r = ImPlot::GetColormapColor(idx, cmap)
func GetColormapColor(idx int, cmap ImPlotColormap) (r imgui.ImVec4) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000043d)
	runtime.AddIntArg(_f, idx)
	runtime.AddIntArg(_f, cmap)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = imgui.ImVec4(runtime.GetFloat32Array4Retr[float32](_f))

	return
}

// SampleColormapU32 Linearly interpolates a color from the current colormap given t between 0 and 1.
//foreign code:
//  auto r = ImPlot::SampleColormapU32(t, cmap)
func SampleColormapU32(t float32, cmap ImPlotColormap) (r uint32) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000043e)
	runtime.AddFloat32Arg(_f, t)
	runtime.AddIntArg(_f, cmap)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetUint32Retr[uint32](_f))

	return
}

// SampleColormap Sample a color from the current colormap given t between 0 and 1.
//foreign code:
//  auto r = ImPlot::SampleColormap(t, cmap)
func SampleColormap(t float32, cmap ImPlotColormap) (r imgui.ImVec4) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000043f)
	runtime.AddFloat32Arg(_f, t)
	runtime.AddIntArg(_f, cmap)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = imgui.ImVec4(runtime.GetFloat32Array4Retr[float32](_f))

	return
}

// ColormapScale Shows a vertical color scale with linear spaced ticks using the specified color map. Use double hashes to hide label (e.g. "##NoLabel"). If scale_min > scale_max, the scale to color mapping will be reversed.
//foreign code:
//  ImPlot::ColormapScale(label, scale_min, scale_max, size, format, flags, cmap)
func ColormapScale(label string, scale_min float64, scale_max float64, size imgui.ImVec2, format string, flags ImPlotColormapScaleFlags, cmap ImPlotColormap) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000440)
	runtime.AddStringArg(_f, label)
	runtime.AddFloat64Arg(_f, scale_min)
	runtime.AddFloat64Arg(_f, scale_max)
	runtime.AddComplex64Arg(_f, size)
	runtime.AddStringArg(_f, format)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, cmap)
	_f.CallProcedure()

}

// ColormapButton Shows a button with a colormap gradient brackground.
//foreign code:
//  auto r = ImPlot::ColormapButton(label, size_arg, cmap)
func ColormapButton(label string, size_arg imgui.ImVec2, cmap ImPlotColormap) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000441)
	runtime.AddStringArg(_f, label)
	runtime.AddComplex64Arg(_f, size_arg)
	runtime.AddIntArg(_f, cmap)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// ItemIcon Render icons similar to those that appear in legends (nifty for data lists).
//foreign code:
//  ImPlot::ItemIcon(col)
func ItemIcon(col imgui.ImVec4) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000442)
	runtime.AddFloat32Array4Arg(_f, col)
	_f.CallProcedure()

}

func ItemIconUint32(col uint32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000443)
	runtime.AddUint32Arg(_f, col)
	_f.CallProcedure()

}

func ColormapIcon(cmap ImPlotColormap) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000444)
	runtime.AddIntArg(_f, cmap)
	_f.CallProcedure()

}

// GetPlotDrawList Get the plot draw list for custom rendering to the current plot area. Call between Begin/EndPlot.
//foreign code:
//  auto r = ImPlot::GetPlotDrawList()
func GetPlotDrawList() (r ImDrawListPtr) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000445)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = ImDrawListPtr(runtime.GetUintptrRetr[uintptr](_f))

	return
}

// PushPlotClipRect Push clip rect for rendering to current plot area. The rect can be expanded or contracted by expand pixels. Call between Begin/EndPlot.
//foreign code:
//  ImPlot::PushPlotClipRect(expand)
func PushPlotClipRect(expand float32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000446)
	runtime.AddFloat32Arg(_f, expand)
	_f.CallProcedure()

}

// PopPlotClipRect Pop plot clip rect. Call between Begin/EndPlot.
//foreign code:
//  ImPlot::PopPlotClipRect()
func PopPlotClipRect() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000447)
	_f.CallProcedure()

}

// ShowStyleSelector Shows ImPlot style selector dropdown menu.
//foreign code:
//  auto r = ImPlot::ShowStyleSelector(label)
func ShowStyleSelector(label string) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000448)
	runtime.AddStringArg(_f, label)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// ShowColormapSelector Shows ImPlot colormap selector dropdown menu.
//foreign code:
//  auto r = ImPlot::ShowColormapSelector(label)
func ShowColormapSelector(label string) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000449)
	runtime.AddStringArg(_f, label)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// ShowInputMapSelector Shows ImPlot input map selector dropdown menu.
//foreign code:
//  auto r = ImPlot::ShowInputMapSelector(label)
func ShowInputMapSelector(label string) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000044a)
	runtime.AddStringArg(_f, label)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// ShowUserGuide Add basic help/info block for end users (not a window).
//foreign code:
//  ImPlot::ShowUserGuide()
func ShowUserGuide() {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000044b)
	_f.CallProcedure()

}

// PlotImage Plots an axis-aligned image. bounds_min/bounds_max are in plot coordinates (y-up) and uv0/uv1 are in texture coordinates (y-down).
//foreign code:
//  ImPlot::PlotImage(label_id, imgui.ImTextureID(user_texture_id), bounds_min, bounds_max)
func PlotImage(label_id string, user_texture_id imgui.ImTextureID, bounds_min ImPlotPoint, bounds_max ImPlotPoint) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000044c)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintptrArg(_f, user_texture_id)
	runtime.AddComplex128Arg(_f, bounds_min)
	runtime.AddComplex128Arg(_f, bounds_max)
	_f.CallProcedure()

}

// PlotImageV Plots an axis-aligned image. bounds_min/bounds_max are in plot coordinates (y-up) and uv0/uv1 are in texture coordinates (y-down).
// * uv0 const imgui.ImVec2 & = imgui.ImVec2(0, 0)
// * uv1 const imgui.ImVec2 & = imgui.ImVec2(1, 1)
// * tint_col const imgui.ImVec4 & = imgui.ImVec4(1, 1, 1, 1)
// * flags ImPlotImageFlags = 0
//foreign code:
//  ImPlot::PlotImage(label_id, imgui.ImTextureID(user_texture_id), bounds_min, bounds_max, uv0, uv1, tint_col, flags)
func PlotImageV(label_id string, user_texture_id imgui.ImTextureID, bounds_min ImPlotPoint, bounds_max ImPlotPoint, uv0 imgui.ImVec2 /* = imgui.ImVec2(0, 0)*/, uv1 imgui.ImVec2 /* = imgui.ImVec2(1, 1)*/, tint_col imgui.ImVec4 /* = imgui.ImVec4(1, 1, 1, 1)*/, flags ImPlotImageFlags /* = 0*/) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000044d)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintptrArg(_f, user_texture_id)
	runtime.AddComplex128Arg(_f, bounds_min)
	runtime.AddComplex128Arg(_f, bounds_max)
	runtime.AddComplex64Arg(_f, uv0)
	runtime.AddComplex64Arg(_f, uv1)
	runtime.AddFloat32Array4Arg(_f, tint_col)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}

// PlotText Plots a centered text label at point x,y with an optional pixel offset. Text color can be changed with ImPlot::PushStyleColor(ImPlotCol_InlayText, ...).
//foreign code:
//  ImPlot::PlotText(text, x, y)
func PlotText(text string, x float64, y float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000044e)
	runtime.AddStringArg(_f, text)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	_f.CallProcedure()

}

// PlotTextV Plots a centered text label at point x,y with an optional pixel offset. Text color can be changed with ImPlot::PushStyleColor(ImPlotCol_InlayText, ...).
// * pix_offset const imgui.ImVec2 & = imgui.ImVec2(0, 0)
// * flags ImPlotTextFlags = 0
//foreign code:
//  ImPlot::PlotText(text, x, y, pix_offset, flags)
func PlotTextV(text string, x float64, y float64, pix_offset imgui.ImVec2 /* = imgui.ImVec2(0, 0)*/, flags ImPlotTextFlags /* = 0*/) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000044f)
	runtime.AddStringArg(_f, text)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddComplex64Arg(_f, pix_offset)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}

// PlotDummy Plots a dummy item (i.e. adds a legend entry colored by ImPlotCol_Line)
//foreign code:
//  ImPlot::PlotDummy(label_id)
func PlotDummy(label_id string) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000450)
	runtime.AddStringArg(_f, label_id)
	_f.CallProcedure()

}

// PlotDummyV Plots a dummy item (i.e. adds a legend entry colored by ImPlotCol_Line)
// * flags ImPlotDummyFlags = 0
//foreign code:
//  ImPlot::PlotDummy(label_id, flags)
func PlotDummyV(label_id string, flags ImPlotDummyFlags /* = 0*/) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000451)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}

// SetNextLineStyle Set the line color and weight for the next item only.The following can be used to modify the style of the next plot item ONLY. They do NOT require calls to PopStyleX. Leave style attributes you don't want modified to IMPLOT_AUTO or IMPLOT_AUTO_COL. Automatic styles will be deduced from the current values in your ImPlotStyle or from Colormap data.
//foreign code:
//  ImPlot::SetNextLineStyle()
func SetNextLineStyle() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000452)
	_f.CallProcedure()

}

// SetNextLineStyleV Set the line color and weight for the next item only.The following can be used to modify the style of the next plot item ONLY. They do NOT require calls to PopStyleX. Leave style attributes you don't want modified to IMPLOT_AUTO or IMPLOT_AUTO_COL. Automatic styles will be deduced from the current values in your ImPlotStyle or from Colormap data.
// * col const imgui.ImVec4 & = IMPLOT_AUTO_COL
// * weight float = IMPLOT_AUTO
//foreign code:
//  ImPlot::SetNextLineStyle(col, weight)
func SetNextLineStyleV(col imgui.ImVec4 /* = IMPLOT_AUTO_COL*/, weight float32 /* = IMPLOT_AUTO*/) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000453)
	runtime.AddFloat32Array4Arg(_f, col)
	runtime.AddFloat32Arg(_f, weight)
	_f.CallProcedure()

}

// SetNextFillStyle Set the fill color for the next item only.
//foreign code:
//  ImPlot::SetNextFillStyle()
func SetNextFillStyle() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000454)
	_f.CallProcedure()

}

// SetNextFillStyleV Set the fill color for the next item only.
// * col const imgui.ImVec4 & = IMPLOT_AUTO_COL
// * alpha_mod float = IMPLOT_AUTO
//foreign code:
//  ImPlot::SetNextFillStyle(col, alpha_mod)
func SetNextFillStyleV(col imgui.ImVec4 /* = IMPLOT_AUTO_COL*/, alpha_mod float32 /* = IMPLOT_AUTO*/) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000455)
	runtime.AddFloat32Array4Arg(_f, col)
	runtime.AddFloat32Arg(_f, alpha_mod)
	_f.CallProcedure()

}

// SetNextMarkerStyle Set the marker style for the next item only.
//foreign code:
//  ImPlot::SetNextMarkerStyle()
func SetNextMarkerStyle() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000456)
	_f.CallProcedure()

}

// SetNextMarkerStyleV Set the marker style for the next item only.
// * marker ImPlotMarker = IMPLOT_AUTO
// * size float = IMPLOT_AUTO
// * fill const imgui.ImVec4 & = IMPLOT_AUTO_COL
// * weight float = IMPLOT_AUTO
// * outline const imgui.ImVec4 & = IMPLOT_AUTO_COL
//foreign code:
//  ImPlot::SetNextMarkerStyle(marker, size, fill, weight, outline)
func SetNextMarkerStyleV(marker ImPlotMarker /* = IMPLOT_AUTO*/, size float32 /* = IMPLOT_AUTO*/, fill imgui.ImVec4 /* = IMPLOT_AUTO_COL*/, weight float32 /* = IMPLOT_AUTO*/, outline imgui.ImVec4 /* = IMPLOT_AUTO_COL*/) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000457)
	runtime.AddIntArg(_f, marker)
	runtime.AddFloat32Arg(_f, size)
	runtime.AddFloat32Array4Arg(_f, fill)
	runtime.AddFloat32Arg(_f, weight)
	runtime.AddFloat32Array4Arg(_f, outline)
	_f.CallProcedure()

}

// SetNextErrorBarStyle Set the error bar style for the next item only.
//foreign code:
//  ImPlot::SetNextErrorBarStyle()
func SetNextErrorBarStyle() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000458)
	_f.CallProcedure()

}

// SetNextErrorBarStyleV Set the error bar style for the next item only.
// * col const imgui.ImVec4 & = IMPLOT_AUTO_COL
// * size float = IMPLOT_AUTO
// * weight float = IMPLOT_AUTO
//foreign code:
//  ImPlot::SetNextErrorBarStyle(col, size, weight)
func SetNextErrorBarStyleV(col imgui.ImVec4 /* = IMPLOT_AUTO_COL*/, size float32 /* = IMPLOT_AUTO*/, weight float32 /* = IMPLOT_AUTO*/) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000459)
	runtime.AddFloat32Array4Arg(_f, col)
	runtime.AddFloat32Arg(_f, size)
	runtime.AddFloat32Arg(_f, weight)
	_f.CallProcedure()

}

// GetLastItemColor Gets the last item primary color (i.e. its legend icon color)
//foreign code:
//  auto r = ImPlot::GetLastItemColor()
func GetLastItemColor() (r imgui.ImVec4) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000045a)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = imgui.ImVec4(runtime.GetFloat32Array4Retr[float32](_f))

	return
}

// BustColorCache When items in a plot sample their color from a colormap, the color is cached and does not change unless explicitly overriden. Therefore, if you change the colormap after the item has already been plotted, item colors will NOT update. If you need item colors to resample the new colormap, then use this function to bust the cached colors. If plot_title_id is nullptr, then every item in EVERY existing plot will be cache busted. Otherwise only the plot specified by plot_title_id will be busted. For the latter, this function must be called in the same imgui.ImGui ID scope that the plot is in. You should rarely if ever need this function, but it is available for applications that require runtime colormap swaps (e.g. Heatmaps demo).
//foreign code:
//  ImPlot::BustColorCache()
func BustColorCache() {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000045b)
	_f.CallProcedure()

}

// BustColorCacheV When items in a plot sample their color from a colormap, the color is cached and does not change unless explicitly overriden. Therefore, if you change the colormap after the item has already been plotted, item colors will NOT update. If you need item colors to resample the new colormap, then use this function to bust the cached colors. If plot_title_id is nullptr, then every item in EVERY existing plot will be cache busted. Otherwise only the plot specified by plot_title_id will be busted. For the latter, this function must be called in the same imgui.ImGui ID scope that the plot is in. You should rarely if ever need this function, but it is available for applications that require runtime colormap swaps (e.g. Heatmaps demo).
// * plot_title_id const char * = nullptr
//foreign code:
//  ImPlot::BustColorCache(plot_title_id)
func BustColorCacheV(plot_title_id string /* = nullptr*/) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000045c)
	runtime.AddStringArg(_f, plot_title_id)
	_f.CallProcedure()

}

// ShowDemoWindow Shows the ImPlot demo window (add implot_demo.cpp to your sources!)
//foreign code:
//  ImPlot::ShowDemoWindow()
func ShowDemoWindow() {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000045d)
	_f.CallProcedure()

}

// BeginItem Begins a new item. Returns false if the item should not be plotted. Pushes PlotClipRect.
//foreign code:
//  auto r = ImPlot::BeginItem(label_id)
func BeginItem(label_id string) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000045e)
	runtime.AddStringArg(_f, label_id)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// BeginItemV Begins a new item. Returns false if the item should not be plotted. Pushes PlotClipRect.
// * flags ImPlotItemFlags = 0
// * recolor_from ImPlotCol = IMPLOT_AUTO
//foreign code:
//  auto r = ImPlot::BeginItem(label_id, flags, recolor_from)
func BeginItemV(label_id string, flags ImPlotItemFlags /* = 0*/, recolor_from ImPlotCol /* = IMPLOT_AUTO*/) (r bool) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000045f)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, recolor_from)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetBoolRetr[bool](_f))

	return
}

// EndItem Ends an item (call only if BeginItem returns true). Pops PlotClipRect.
//foreign code:
//  ImPlot::EndItem()
func EndItem() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000460)
	_f.CallProcedure()

}

// BustItemCache Busts the cache for every item for every plot in the current context.
//foreign code:
//  ImPlot::BustItemCache()
func BustItemCache() {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000461)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarGroupsFloat32(label_ids NullSeparatedStringArray, values []float32, groups int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000462)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddFloat32SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	_f.CallProcedure()
}

func PlotBarGroupsFloat32V(label_ids NullSeparatedStringArray, values []float32, groups int, size float64, shift float64, flags ImPlotBarGroupsFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000463)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddFloat32SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	runtime.AddFloat64Arg(_f, size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarGroupsFloat64(label_ids NullSeparatedStringArray, values []float64, groups int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000464)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddFloat64SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	_f.CallProcedure()
}

func PlotBarGroupsFloat64V(label_ids NullSeparatedStringArray, values []float64, groups int, size float64, shift float64, flags ImPlotBarGroupsFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000465)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddFloat64SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	runtime.AddFloat64Arg(_f, size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarGroupsInt(label_ids NullSeparatedStringArray, values []int, groups int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000466)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddIntSliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	_f.CallProcedure()
}

func PlotBarGroupsIntV(label_ids NullSeparatedStringArray, values []int, groups int, size float64, shift float64, flags ImPlotBarGroupsFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000467)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddIntSliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	runtime.AddFloat64Arg(_f, size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarGroupsInt16(label_ids NullSeparatedStringArray, values []int16, groups int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000468)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddInt16SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	_f.CallProcedure()
}

func PlotBarGroupsInt16V(label_ids NullSeparatedStringArray, values []int16, groups int, size float64, shift float64, flags ImPlotBarGroupsFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000469)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddInt16SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	runtime.AddFloat64Arg(_f, size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarGroupsInt32(label_ids NullSeparatedStringArray, values []int32, groups int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000046a)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddInt32SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	_f.CallProcedure()
}

func PlotBarGroupsInt32V(label_ids NullSeparatedStringArray, values []int32, groups int, size float64, shift float64, flags ImPlotBarGroupsFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000046b)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddInt32SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	runtime.AddFloat64Arg(_f, size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarGroupsInt8(label_ids NullSeparatedStringArray, values []int8, groups int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000046c)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddInt8SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	_f.CallProcedure()
}

func PlotBarGroupsInt8V(label_ids NullSeparatedStringArray, values []int8, groups int, size float64, shift float64, flags ImPlotBarGroupsFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000046d)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddInt8SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	runtime.AddFloat64Arg(_f, size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarGroupsUInt(label_ids NullSeparatedStringArray, values []uint, groups int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000046e)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUintSliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	_f.CallProcedure()
}

func PlotBarGroupsUIntV(label_ids NullSeparatedStringArray, values []uint, groups int, size float64, shift float64, flags ImPlotBarGroupsFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000046f)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUintSliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	runtime.AddFloat64Arg(_f, size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarGroupsUInt16(label_ids NullSeparatedStringArray, values []uint16, groups int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000470)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUint16SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	_f.CallProcedure()
}

func PlotBarGroupsUInt16V(label_ids NullSeparatedStringArray, values []uint16, groups int, size float64, shift float64, flags ImPlotBarGroupsFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000471)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUint16SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	runtime.AddFloat64Arg(_f, size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarGroupsUInt32(label_ids NullSeparatedStringArray, values []uint32, groups int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000472)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUint32SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	_f.CallProcedure()
}

func PlotBarGroupsUInt32V(label_ids NullSeparatedStringArray, values []uint32, groups int, size float64, shift float64, flags ImPlotBarGroupsFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000473)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUint32SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	runtime.AddFloat64Arg(_f, size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarGroupsUInt8(label_ids NullSeparatedStringArray, values []uint8, groups int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000474)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUint8SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	_f.CallProcedure()
}

func PlotBarGroupsUInt8V(label_ids NullSeparatedStringArray, values []uint8, groups int, size float64, shift float64, flags ImPlotBarGroupsFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000475)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUint8SliceArg(_f, values)
	runtime.AddIntArg(_f, groups)
	runtime.AddFloat64Arg(_f, size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarsFloat32(label_id string, values []float32) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000476)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotBarsFloat32V(label_id string, values []float32, bar_size float64, shift float64, flags ImPlotBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000477)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotBarsXYFloat32(label_id string, xs []float32, ys []float32, bar_size float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000478)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	_f.CallProcedure()

}

func PlotBarsXYFloat32V(label_id string, xs []float32, ys []float32, bar_size float64, flags ImPlotBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000479)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarsFloat64(label_id string, values []float64) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000047a)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotBarsFloat64V(label_id string, values []float64, bar_size float64, shift float64, flags ImPlotBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000047b)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotBarsXYFloat64(label_id string, xs []float64, ys []float64, bar_size float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000047c)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	_f.CallProcedure()

}

func PlotBarsXYFloat64V(label_id string, xs []float64, ys []float64, bar_size float64, flags ImPlotBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000047d)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarsInt(label_id string, values []int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000047e)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	_f.CallProcedure()
}

func PlotBarsIntV(label_id string, values []int, bar_size float64, shift float64, flags ImPlotBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000047f)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotBarsXYInt(label_id string, xs []int, ys []int, bar_size float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000480)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	_f.CallProcedure()

}

func PlotBarsXYIntV(label_id string, xs []int, ys []int, bar_size float64, flags ImPlotBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000481)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarsInt16(label_id string, values []int16) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000482)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotBarsInt16V(label_id string, values []int16, bar_size float64, shift float64, flags ImPlotBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000483)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotBarsXYInt16(label_id string, xs []int16, ys []int16, bar_size float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000484)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	_f.CallProcedure()

}

func PlotBarsXYInt16V(label_id string, xs []int16, ys []int16, bar_size float64, flags ImPlotBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000485)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarsInt32(label_id string, values []int32) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000486)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotBarsInt32V(label_id string, values []int32, bar_size float64, shift float64, flags ImPlotBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000487)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotBarsXYInt32(label_id string, xs []int32, ys []int32, bar_size float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000488)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	_f.CallProcedure()

}

func PlotBarsXYInt32V(label_id string, xs []int32, ys []int32, bar_size float64, flags ImPlotBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000489)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarsInt8(label_id string, values []int8) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000048a)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotBarsInt8V(label_id string, values []int8, bar_size float64, shift float64, flags ImPlotBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000048b)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotBarsXYInt8(label_id string, xs []int8, ys []int8, bar_size float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000048c)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	_f.CallProcedure()

}

func PlotBarsXYInt8V(label_id string, xs []int8, ys []int8, bar_size float64, flags ImPlotBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000048d)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarsUInt(label_id string, values []uint) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000048e)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	_f.CallProcedure()
}

func PlotBarsUIntV(label_id string, values []uint, bar_size float64, shift float64, flags ImPlotBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000048f)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotBarsXYUInt(label_id string, xs []uint, ys []uint, bar_size float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000490)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	_f.CallProcedure()

}

func PlotBarsXYUIntV(label_id string, xs []uint, ys []uint, bar_size float64, flags ImPlotBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000491)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarsUInt16(label_id string, values []uint16) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000492)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotBarsUInt16V(label_id string, values []uint16, bar_size float64, shift float64, flags ImPlotBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000493)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotBarsXYUInt16(label_id string, xs []uint16, ys []uint16, bar_size float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000494)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	_f.CallProcedure()

}

func PlotBarsXYUInt16V(label_id string, xs []uint16, ys []uint16, bar_size float64, flags ImPlotBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000495)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarsUInt32(label_id string, values []uint32) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000496)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotBarsUInt32V(label_id string, values []uint32, bar_size float64, shift float64, flags ImPlotBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000497)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotBarsXYUInt32(label_id string, xs []uint32, ys []uint32, bar_size float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000498)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	_f.CallProcedure()

}

func PlotBarsXYUInt32V(label_id string, xs []uint32, ys []uint32, bar_size float64, flags ImPlotBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000499)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotBarsUInt8(label_id string, values []uint8) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000049a)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotBarsUInt8V(label_id string, values []uint8, bar_size float64, shift float64, flags ImPlotBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000049b)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddFloat64Arg(_f, shift)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotBarsXYUInt8(label_id string, xs []uint8, ys []uint8, bar_size float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000049c)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	_f.CallProcedure()

}

func PlotBarsXYUInt8V(label_id string, xs []uint8, ys []uint8, bar_size float64, flags ImPlotBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000049d)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, bar_size)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotDigitalFloat32[T ~float32](label_id string, xs []T, ys []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000049e)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	_f.CallProcedure()
}

func PlotDigitalFloat32V[T ~float32](label_id string, xs []T, ys []T, flags ImPlotDigitalFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000049f)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotDigitalFloat64[T ~float64](label_id string, xs []T, ys []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004a0)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	_f.CallProcedure()
}

func PlotDigitalFloat64V[T ~float64](label_id string, xs []T, ys []T, flags ImPlotDigitalFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004a1)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotDigitalInt[T ~int](label_id string, xs []T, ys []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004a2)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	_f.CallProcedure()
}

func PlotDigitalIntV[T ~int](label_id string, xs []T, ys []T, flags ImPlotDigitalFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004a3)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotDigitalInt16[T ~int16](label_id string, xs []T, ys []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004a4)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	_f.CallProcedure()
}

func PlotDigitalInt16V[T ~int16](label_id string, xs []T, ys []T, flags ImPlotDigitalFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004a5)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotDigitalInt32[T ~int32](label_id string, xs []T, ys []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004a6)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	_f.CallProcedure()
}

func PlotDigitalInt32V[T ~int32](label_id string, xs []T, ys []T, flags ImPlotDigitalFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004a7)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotDigitalInt8[T ~int8](label_id string, xs []T, ys []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004a8)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	_f.CallProcedure()
}

func PlotDigitalInt8V[T ~int8](label_id string, xs []T, ys []T, flags ImPlotDigitalFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004a9)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotDigitalUInt[T ~uint](label_id string, xs []T, ys []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004aa)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	_f.CallProcedure()
}

func PlotDigitalUIntV[T ~uint](label_id string, xs []T, ys []T, flags ImPlotDigitalFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004ab)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotDigitalUInt16[T ~uint16](label_id string, xs []T, ys []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004ac)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	_f.CallProcedure()
}

func PlotDigitalUInt16V[T ~uint16](label_id string, xs []T, ys []T, flags ImPlotDigitalFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004ad)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotDigitalUInt32[T ~uint32](label_id string, xs []T, ys []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004ae)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	_f.CallProcedure()
}

func PlotDigitalUInt32V[T ~uint32](label_id string, xs []T, ys []T, flags ImPlotDigitalFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004af)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotDigitalUInt8[T ~uint8](label_id string, xs []T, ys []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004b0)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	_f.CallProcedure()
}

func PlotDigitalUInt8V[T ~uint8](label_id string, xs []T, ys []T, flags ImPlotDigitalFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004b1)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotErrorBarsFloat32[T ~float32](label_id string, xs []T, ys []T, errs []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004b2)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	runtime.AddFloat32SliceArg(_f, errs)
	_f.CallProcedure()
}

func PlotErrorBarsFloat32V[T ~float32](label_id string, xs []T, ys []T, errs []T, flags ImPlotErrorBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004b3)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	runtime.AddFloat32SliceArg(_f, errs)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotErrorBarsPosNegFloat32[T ~float32](label_id string, xs []T, ys []T, neg []T, pos []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004b4)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	runtime.AddFloat32SliceArg(_f, neg)
	runtime.AddFloat32SliceArg(_f, pos)
	_f.CallProcedure()

}

func PlotErrorBarsPosNegFloat32V[T ~float32](label_id string, xs []T, ys []T, neg []T, pos []T, flags ImPlotErrorBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004b5)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	runtime.AddFloat32SliceArg(_f, neg)
	runtime.AddFloat32SliceArg(_f, pos)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotErrorBarsFloat64[T ~float64](label_id string, xs []T, ys []T, errs []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004b6)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	runtime.AddFloat64SliceArg(_f, errs)
	_f.CallProcedure()
}

func PlotErrorBarsFloat64V[T ~float64](label_id string, xs []T, ys []T, errs []T, flags ImPlotErrorBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004b7)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	runtime.AddFloat64SliceArg(_f, errs)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotErrorBarsPosNegFloat64[T ~float64](label_id string, xs []T, ys []T, neg []T, pos []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004b8)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	runtime.AddFloat64SliceArg(_f, neg)
	runtime.AddFloat64SliceArg(_f, pos)
	_f.CallProcedure()

}

func PlotErrorBarsPosNegFloat64V[T ~float64](label_id string, xs []T, ys []T, neg []T, pos []T, flags ImPlotErrorBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004b9)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	runtime.AddFloat64SliceArg(_f, neg)
	runtime.AddFloat64SliceArg(_f, pos)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotErrorBarsInt[T ~int](label_id string, xs []T, ys []T, errs []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004ba)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	runtime.AddIntSliceArg(_f, errs)
	_f.CallProcedure()
}

func PlotErrorBarsIntV[T ~int](label_id string, xs []T, ys []T, errs []T, flags ImPlotErrorBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004bb)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	runtime.AddIntSliceArg(_f, errs)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotErrorBarsPosNegInt[T ~int](label_id string, xs []T, ys []T, neg []T, pos []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004bc)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	runtime.AddIntSliceArg(_f, neg)
	runtime.AddIntSliceArg(_f, pos)
	_f.CallProcedure()

}

func PlotErrorBarsPosNegIntV[T ~int](label_id string, xs []T, ys []T, neg []T, pos []T, flags ImPlotErrorBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004bd)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	runtime.AddIntSliceArg(_f, neg)
	runtime.AddIntSliceArg(_f, pos)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotErrorBarsInt16[T ~int16](label_id string, xs []T, ys []T, errs []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004be)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	runtime.AddInt16SliceArg(_f, errs)
	_f.CallProcedure()
}

func PlotErrorBarsInt16V[T ~int16](label_id string, xs []T, ys []T, errs []T, flags ImPlotErrorBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004bf)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	runtime.AddInt16SliceArg(_f, errs)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotErrorBarsPosNegInt16[T ~int16](label_id string, xs []T, ys []T, neg []T, pos []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004c0)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	runtime.AddInt16SliceArg(_f, neg)
	runtime.AddInt16SliceArg(_f, pos)
	_f.CallProcedure()

}

func PlotErrorBarsPosNegInt16V[T ~int16](label_id string, xs []T, ys []T, neg []T, pos []T, flags ImPlotErrorBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004c1)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	runtime.AddInt16SliceArg(_f, neg)
	runtime.AddInt16SliceArg(_f, pos)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotErrorBarsInt32[T ~int32](label_id string, xs []T, ys []T, errs []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004c2)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	runtime.AddInt32SliceArg(_f, errs)
	_f.CallProcedure()
}

func PlotErrorBarsInt32V[T ~int32](label_id string, xs []T, ys []T, errs []T, flags ImPlotErrorBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004c3)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	runtime.AddInt32SliceArg(_f, errs)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotErrorBarsPosNegInt32[T ~int32](label_id string, xs []T, ys []T, neg []T, pos []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004c4)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	runtime.AddInt32SliceArg(_f, neg)
	runtime.AddInt32SliceArg(_f, pos)
	_f.CallProcedure()

}

func PlotErrorBarsPosNegInt32V[T ~int32](label_id string, xs []T, ys []T, neg []T, pos []T, flags ImPlotErrorBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004c5)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	runtime.AddInt32SliceArg(_f, neg)
	runtime.AddInt32SliceArg(_f, pos)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotErrorBarsInt8[T ~int8](label_id string, xs []T, ys []T, errs []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004c6)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	runtime.AddInt8SliceArg(_f, errs)
	_f.CallProcedure()
}

func PlotErrorBarsInt8V[T ~int8](label_id string, xs []T, ys []T, errs []T, flags ImPlotErrorBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004c7)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	runtime.AddInt8SliceArg(_f, errs)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotErrorBarsPosNegInt8[T ~int8](label_id string, xs []T, ys []T, neg []T, pos []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004c8)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	runtime.AddInt8SliceArg(_f, neg)
	runtime.AddInt8SliceArg(_f, pos)
	_f.CallProcedure()

}

func PlotErrorBarsPosNegInt8V[T ~int8](label_id string, xs []T, ys []T, neg []T, pos []T, flags ImPlotErrorBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004c9)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	runtime.AddInt8SliceArg(_f, neg)
	runtime.AddInt8SliceArg(_f, pos)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotErrorBarsUInt[T ~uint](label_id string, xs []T, ys []T, errs []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004ca)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	runtime.AddUintSliceArg(_f, errs)
	_f.CallProcedure()
}

func PlotErrorBarsUIntV[T ~uint](label_id string, xs []T, ys []T, errs []T, flags ImPlotErrorBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004cb)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	runtime.AddUintSliceArg(_f, errs)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotErrorBarsPosNegUInt[T ~uint](label_id string, xs []T, ys []T, neg []T, pos []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004cc)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	runtime.AddUintSliceArg(_f, neg)
	runtime.AddUintSliceArg(_f, pos)
	_f.CallProcedure()

}

func PlotErrorBarsPosNegUIntV[T ~uint](label_id string, xs []T, ys []T, neg []T, pos []T, flags ImPlotErrorBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004cd)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	runtime.AddUintSliceArg(_f, neg)
	runtime.AddUintSliceArg(_f, pos)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotErrorBarsUInt16[T ~uint16](label_id string, xs []T, ys []T, errs []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004ce)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	runtime.AddUint16SliceArg(_f, errs)
	_f.CallProcedure()
}

func PlotErrorBarsUInt16V[T ~uint16](label_id string, xs []T, ys []T, errs []T, flags ImPlotErrorBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004cf)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	runtime.AddUint16SliceArg(_f, errs)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotErrorBarsPosNegUInt16[T ~uint16](label_id string, xs []T, ys []T, neg []T, pos []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004d0)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	runtime.AddUint16SliceArg(_f, neg)
	runtime.AddUint16SliceArg(_f, pos)
	_f.CallProcedure()

}

func PlotErrorBarsPosNegUInt16V[T ~uint16](label_id string, xs []T, ys []T, neg []T, pos []T, flags ImPlotErrorBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004d1)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	runtime.AddUint16SliceArg(_f, neg)
	runtime.AddUint16SliceArg(_f, pos)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotErrorBarsUInt32[T ~uint32](label_id string, xs []T, ys []T, errs []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004d2)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	runtime.AddUint32SliceArg(_f, errs)
	_f.CallProcedure()
}

func PlotErrorBarsUInt32V[T ~uint32](label_id string, xs []T, ys []T, errs []T, flags ImPlotErrorBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004d3)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	runtime.AddUint32SliceArg(_f, errs)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotErrorBarsPosNegUInt32[T ~uint32](label_id string, xs []T, ys []T, neg []T, pos []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004d4)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	runtime.AddUint32SliceArg(_f, neg)
	runtime.AddUint32SliceArg(_f, pos)
	_f.CallProcedure()

}

func PlotErrorBarsPosNegUInt32V[T ~uint32](label_id string, xs []T, ys []T, neg []T, pos []T, flags ImPlotErrorBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004d5)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	runtime.AddUint32SliceArg(_f, neg)
	runtime.AddUint32SliceArg(_f, pos)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotErrorBarsUInt8[T ~uint8](label_id string, xs []T, ys []T, errs []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004d6)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	runtime.AddUint8SliceArg(_f, errs)
	_f.CallProcedure()
}

func PlotErrorBarsUInt8V[T ~uint8](label_id string, xs []T, ys []T, errs []T, flags ImPlotErrorBarsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004d7)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	runtime.AddUint8SliceArg(_f, errs)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotErrorBarsPosNegUInt8[T ~uint8](label_id string, xs []T, ys []T, neg []T, pos []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004d8)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	runtime.AddUint8SliceArg(_f, neg)
	runtime.AddUint8SliceArg(_f, pos)
	_f.CallProcedure()

}

func PlotErrorBarsPosNegUInt8V[T ~uint8](label_id string, xs []T, ys []T, neg []T, pos []T, flags ImPlotErrorBarsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000004d9)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	runtime.AddUint8SliceArg(_f, neg)
	runtime.AddUint8SliceArg(_f, pos)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHeatmapFloat32[T ~float32](label_id string, values []T, rows int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004da)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	_f.CallProcedure()
}

func PlotHeatmapFloat32V[T ~float32](label_id string, values []T, rows int, scale_min float64, scale_max float64, label_fmt string, bounds_min ImPlotPoint, bounds_max ImPlotPoint, flags ImPlotHeatmapFlags) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004db)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	runtime.AddFloat64Arg(_f, scale_min)
	runtime.AddFloat64Arg(_f, scale_max)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddComplex128Arg(_f, bounds_min)
	runtime.AddComplex128Arg(_f, bounds_max)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHeatmapFloat64[T ~float64](label_id string, values []T, rows int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004dc)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	_f.CallProcedure()
}

func PlotHeatmapFloat64V[T ~float64](label_id string, values []T, rows int, scale_min float64, scale_max float64, label_fmt string, bounds_min ImPlotPoint, bounds_max ImPlotPoint, flags ImPlotHeatmapFlags) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004dd)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	runtime.AddFloat64Arg(_f, scale_min)
	runtime.AddFloat64Arg(_f, scale_max)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddComplex128Arg(_f, bounds_min)
	runtime.AddComplex128Arg(_f, bounds_max)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHeatmapInt[T ~int](label_id string, values []T, rows int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004de)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	_f.CallProcedure()
}

func PlotHeatmapIntV[T ~int](label_id string, values []T, rows int, scale_min float64, scale_max float64, label_fmt string, bounds_min ImPlotPoint, bounds_max ImPlotPoint, flags ImPlotHeatmapFlags) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004df)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	runtime.AddFloat64Arg(_f, scale_min)
	runtime.AddFloat64Arg(_f, scale_max)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddComplex128Arg(_f, bounds_min)
	runtime.AddComplex128Arg(_f, bounds_max)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHeatmapInt16[T ~int16](label_id string, values []T, rows int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004e0)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	_f.CallProcedure()
}

func PlotHeatmapInt16V[T ~int16](label_id string, values []T, rows int, scale_min float64, scale_max float64, label_fmt string, bounds_min ImPlotPoint, bounds_max ImPlotPoint, flags ImPlotHeatmapFlags) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004e1)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	runtime.AddFloat64Arg(_f, scale_min)
	runtime.AddFloat64Arg(_f, scale_max)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddComplex128Arg(_f, bounds_min)
	runtime.AddComplex128Arg(_f, bounds_max)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHeatmapInt32[T ~int32](label_id string, values []T, rows int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004e2)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	_f.CallProcedure()
}

func PlotHeatmapInt32V[T ~int32](label_id string, values []T, rows int, scale_min float64, scale_max float64, label_fmt string, bounds_min ImPlotPoint, bounds_max ImPlotPoint, flags ImPlotHeatmapFlags) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004e3)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	runtime.AddFloat64Arg(_f, scale_min)
	runtime.AddFloat64Arg(_f, scale_max)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddComplex128Arg(_f, bounds_min)
	runtime.AddComplex128Arg(_f, bounds_max)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHeatmapInt8[T ~int8](label_id string, values []T, rows int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004e4)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	_f.CallProcedure()
}

func PlotHeatmapInt8V[T ~int8](label_id string, values []T, rows int, scale_min float64, scale_max float64, label_fmt string, bounds_min ImPlotPoint, bounds_max ImPlotPoint, flags ImPlotHeatmapFlags) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004e5)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	runtime.AddFloat64Arg(_f, scale_min)
	runtime.AddFloat64Arg(_f, scale_max)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddComplex128Arg(_f, bounds_min)
	runtime.AddComplex128Arg(_f, bounds_max)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHeatmapUInt[T ~uint](label_id string, values []T, rows int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004e6)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	_f.CallProcedure()
}

func PlotHeatmapUIntV[T ~uint](label_id string, values []T, rows int, scale_min float64, scale_max float64, label_fmt string, bounds_min ImPlotPoint, bounds_max ImPlotPoint, flags ImPlotHeatmapFlags) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004e7)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	runtime.AddFloat64Arg(_f, scale_min)
	runtime.AddFloat64Arg(_f, scale_max)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddComplex128Arg(_f, bounds_min)
	runtime.AddComplex128Arg(_f, bounds_max)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHeatmapUInt16[T ~uint16](label_id string, values []T, rows int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004e8)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	_f.CallProcedure()
}

func PlotHeatmapUInt16V[T ~uint16](label_id string, values []T, rows int, scale_min float64, scale_max float64, label_fmt string, bounds_min ImPlotPoint, bounds_max ImPlotPoint, flags ImPlotHeatmapFlags) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004e9)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	runtime.AddFloat64Arg(_f, scale_min)
	runtime.AddFloat64Arg(_f, scale_max)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddComplex128Arg(_f, bounds_min)
	runtime.AddComplex128Arg(_f, bounds_max)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHeatmapUInt32[T ~uint32](label_id string, values []T, rows int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004ea)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	_f.CallProcedure()
}

func PlotHeatmapUInt32V[T ~uint32](label_id string, values []T, rows int, scale_min float64, scale_max float64, label_fmt string, bounds_min ImPlotPoint, bounds_max ImPlotPoint, flags ImPlotHeatmapFlags) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004eb)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	runtime.AddFloat64Arg(_f, scale_min)
	runtime.AddFloat64Arg(_f, scale_max)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddComplex128Arg(_f, bounds_min)
	runtime.AddComplex128Arg(_f, bounds_max)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHeatmapUInt8[T ~uint8](label_id string, values []T, rows int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004ec)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	_f.CallProcedure()
}

func PlotHeatmapUInt8V[T ~uint8](label_id string, values []T, rows int, scale_min float64, scale_max float64, label_fmt string, bounds_min ImPlotPoint, bounds_max ImPlotPoint, flags ImPlotHeatmapFlags) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000004ed)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	runtime.AddIntArg(_f, rows)
	runtime.AddFloat64Arg(_f, scale_min)
	runtime.AddFloat64Arg(_f, scale_max)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddComplex128Arg(_f, bounds_min)
	runtime.AddComplex128Arg(_f, bounds_max)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHistogramFloat32[T ~float32](label_id string, values []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004ee)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

func PlotHistogramFloat32V[T ~float32](label_id string, values []T, bins ImPlotBin, bar_scale float64, rangeP ImPlotRange, flags ImPlotHistogramFlags) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004ef)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	runtime.AddIntArg(_f, bins)
	runtime.AddFloat64Arg(_f, bar_scale)
	runtime.AddComplex128Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHistogramFloat64[T ~float64](label_id string, values []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004f0)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

func PlotHistogramFloat64V[T ~float64](label_id string, values []T, bins ImPlotBin, bar_scale float64, rangeP ImPlotRange, flags ImPlotHistogramFlags) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004f1)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	runtime.AddIntArg(_f, bins)
	runtime.AddFloat64Arg(_f, bar_scale)
	runtime.AddComplex128Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHistogramInt[T ~int](label_id string, values []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004f2)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

func PlotHistogramIntV[T ~int](label_id string, values []T, bins ImPlotBin, bar_scale float64, rangeP ImPlotRange, flags ImPlotHistogramFlags) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004f3)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	runtime.AddIntArg(_f, bins)
	runtime.AddFloat64Arg(_f, bar_scale)
	runtime.AddComplex128Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHistogramInt16[T ~int16](label_id string, values []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004f4)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

func PlotHistogramInt16V[T ~int16](label_id string, values []T, bins ImPlotBin, bar_scale float64, rangeP ImPlotRange, flags ImPlotHistogramFlags) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004f5)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	runtime.AddIntArg(_f, bins)
	runtime.AddFloat64Arg(_f, bar_scale)
	runtime.AddComplex128Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHistogramInt32[T ~int32](label_id string, values []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004f6)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

func PlotHistogramInt32V[T ~int32](label_id string, values []T, bins ImPlotBin, bar_scale float64, rangeP ImPlotRange, flags ImPlotHistogramFlags) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004f7)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	runtime.AddIntArg(_f, bins)
	runtime.AddFloat64Arg(_f, bar_scale)
	runtime.AddComplex128Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHistogramInt8[T ~int8](label_id string, values []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004f8)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

func PlotHistogramInt8V[T ~int8](label_id string, values []T, bins ImPlotBin, bar_scale float64, rangeP ImPlotRange, flags ImPlotHistogramFlags) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004f9)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	runtime.AddIntArg(_f, bins)
	runtime.AddFloat64Arg(_f, bar_scale)
	runtime.AddComplex128Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHistogramUInt[T ~uint](label_id string, values []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004fa)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

func PlotHistogramUIntV[T ~uint](label_id string, values []T, bins ImPlotBin, bar_scale float64, rangeP ImPlotRange, flags ImPlotHistogramFlags) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004fb)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	runtime.AddIntArg(_f, bins)
	runtime.AddFloat64Arg(_f, bar_scale)
	runtime.AddComplex128Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHistogramUInt16[T ~uint16](label_id string, values []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004fc)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

func PlotHistogramUInt16V[T ~uint16](label_id string, values []T, bins ImPlotBin, bar_scale float64, rangeP ImPlotRange, flags ImPlotHistogramFlags) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004fd)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	runtime.AddIntArg(_f, bins)
	runtime.AddFloat64Arg(_f, bar_scale)
	runtime.AddComplex128Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHistogramUInt32[T ~uint32](label_id string, values []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004fe)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

func PlotHistogramUInt32V[T ~uint32](label_id string, values []T, bins ImPlotBin, bar_scale float64, rangeP ImPlotRange, flags ImPlotHistogramFlags) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x000004ff)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	runtime.AddIntArg(_f, bins)
	runtime.AddFloat64Arg(_f, bar_scale)
	runtime.AddComplex128Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotHistogramUInt8[T ~uint8](label_id string, values []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x00000500)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

func PlotHistogramUInt8V[T ~uint8](label_id string, values []T, bins ImPlotBin, bar_scale float64, rangeP ImPlotRange, flags ImPlotHistogramFlags) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x00000501)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	runtime.AddIntArg(_f, bins)
	runtime.AddFloat64Arg(_f, bar_scale)
	runtime.AddComplex128Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

// PlotHistogram2DFloat32 Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,getSliceLength(xs))
func PlotHistogram2DFloat32[T ~float32](label_id string, xs []T, ys []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x00000502)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

// PlotHistogram2DV Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,(int)getSliceLength(xs),x_bins,y_bins,ImPlotRect(rangeP[0],rangeP[1],rangeP[2],rangeP[3]),flags)
func PlotHistogram2DFloat32V[T ~float32](label_id string, xs []T, ys []T, x_bins ImPlotBin, y_bins ImPlotBin, rangeP ImPlotRect, flags ImPlotHistogramFlags) (r float64) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000503)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	runtime.AddIntArg(_f, x_bins)
	runtime.AddIntArg(_f, y_bins)
	runtime.AddFloat64Array4Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))

	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

// PlotHistogram2DFloat64 Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,getSliceLength(xs))
func PlotHistogram2DFloat64[T ~float64](label_id string, xs []T, ys []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x00000504)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

// PlotHistogram2DV Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,(int)getSliceLength(xs),x_bins,y_bins,ImPlotRect(rangeP[0],rangeP[1],rangeP[2],rangeP[3]),flags)
func PlotHistogram2DFloat64V[T ~float64](label_id string, xs []T, ys []T, x_bins ImPlotBin, y_bins ImPlotBin, rangeP ImPlotRect, flags ImPlotHistogramFlags) (r float64) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000505)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	runtime.AddIntArg(_f, x_bins)
	runtime.AddIntArg(_f, y_bins)
	runtime.AddFloat64Array4Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))

	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

// PlotHistogram2DInt Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,getSliceLength(xs))
func PlotHistogram2DInt[T ~int](label_id string, xs []T, ys []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x00000506)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

// PlotHistogram2DV Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,(int)getSliceLength(xs),x_bins,y_bins,ImPlotRect(rangeP[0],rangeP[1],rangeP[2],rangeP[3]),flags)
func PlotHistogram2DIntV[T ~int](label_id string, xs []T, ys []T, x_bins ImPlotBin, y_bins ImPlotBin, rangeP ImPlotRect, flags ImPlotHistogramFlags) (r float64) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000507)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	runtime.AddIntArg(_f, x_bins)
	runtime.AddIntArg(_f, y_bins)
	runtime.AddFloat64Array4Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))

	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

// PlotHistogram2DInt16 Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,getSliceLength(xs))
func PlotHistogram2DInt16[T ~int16](label_id string, xs []T, ys []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x00000508)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

// PlotHistogram2DV Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,(int)getSliceLength(xs),x_bins,y_bins,ImPlotRect(rangeP[0],rangeP[1],rangeP[2],rangeP[3]),flags)
func PlotHistogram2DInt16V[T ~int16](label_id string, xs []T, ys []T, x_bins ImPlotBin, y_bins ImPlotBin, rangeP ImPlotRect, flags ImPlotHistogramFlags) (r float64) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000509)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	runtime.AddIntArg(_f, x_bins)
	runtime.AddIntArg(_f, y_bins)
	runtime.AddFloat64Array4Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))

	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

// PlotHistogram2DInt32 Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,getSliceLength(xs))
func PlotHistogram2DInt32[T ~int32](label_id string, xs []T, ys []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x0000050a)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

// PlotHistogram2DV Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,(int)getSliceLength(xs),x_bins,y_bins,ImPlotRect(rangeP[0],rangeP[1],rangeP[2],rangeP[3]),flags)
func PlotHistogram2DInt32V[T ~int32](label_id string, xs []T, ys []T, x_bins ImPlotBin, y_bins ImPlotBin, rangeP ImPlotRect, flags ImPlotHistogramFlags) (r float64) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000050b)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	runtime.AddIntArg(_f, x_bins)
	runtime.AddIntArg(_f, y_bins)
	runtime.AddFloat64Array4Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))

	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

// PlotHistogram2DInt8 Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,getSliceLength(xs))
func PlotHistogram2DInt8[T ~int8](label_id string, xs []T, ys []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x0000050c)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

// PlotHistogram2DV Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,(int)getSliceLength(xs),x_bins,y_bins,ImPlotRect(rangeP[0],rangeP[1],rangeP[2],rangeP[3]),flags)
func PlotHistogram2DInt8V[T ~int8](label_id string, xs []T, ys []T, x_bins ImPlotBin, y_bins ImPlotBin, rangeP ImPlotRect, flags ImPlotHistogramFlags) (r float64) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000050d)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	runtime.AddIntArg(_f, x_bins)
	runtime.AddIntArg(_f, y_bins)
	runtime.AddFloat64Array4Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))

	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

// PlotHistogram2DUInt Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,getSliceLength(xs))
func PlotHistogram2DUInt[T ~uint](label_id string, xs []T, ys []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x0000050e)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

// PlotHistogram2DV Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,(int)getSliceLength(xs),x_bins,y_bins,ImPlotRect(rangeP[0],rangeP[1],rangeP[2],rangeP[3]),flags)
func PlotHistogram2DUIntV[T ~uint](label_id string, xs []T, ys []T, x_bins ImPlotBin, y_bins ImPlotBin, rangeP ImPlotRect, flags ImPlotHistogramFlags) (r float64) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000050f)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	runtime.AddIntArg(_f, x_bins)
	runtime.AddIntArg(_f, y_bins)
	runtime.AddFloat64Array4Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))

	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

// PlotHistogram2DUInt16 Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,getSliceLength(xs))
func PlotHistogram2DUInt16[T ~uint16](label_id string, xs []T, ys []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x00000510)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

// PlotHistogram2DV Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,(int)getSliceLength(xs),x_bins,y_bins,ImPlotRect(rangeP[0],rangeP[1],rangeP[2],rangeP[3]),flags)
func PlotHistogram2DUInt16V[T ~uint16](label_id string, xs []T, ys []T, x_bins ImPlotBin, y_bins ImPlotBin, rangeP ImPlotRect, flags ImPlotHistogramFlags) (r float64) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000511)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	runtime.AddIntArg(_f, x_bins)
	runtime.AddIntArg(_f, y_bins)
	runtime.AddFloat64Array4Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))

	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

// PlotHistogram2DUInt32 Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,getSliceLength(xs))
func PlotHistogram2DUInt32[T ~uint32](label_id string, xs []T, ys []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x00000512)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

// PlotHistogram2DV Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,(int)getSliceLength(xs),x_bins,y_bins,ImPlotRect(rangeP[0],rangeP[1],rangeP[2],rangeP[3]),flags)
func PlotHistogram2DUInt32V[T ~uint32](label_id string, xs []T, ys []T, x_bins ImPlotBin, y_bins ImPlotBin, rangeP ImPlotRect, flags ImPlotHistogramFlags) (r float64) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000513)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	runtime.AddIntArg(_f, x_bins)
	runtime.AddIntArg(_f, y_bins)
	runtime.AddFloat64Array4Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))

	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

// PlotHistogram2DUInt8 Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,getSliceLength(xs))
func PlotHistogram2DUInt8[T ~uint8](label_id string, xs []T, ys []T) (r float64) {

	_f := currentFffiVar
	_f.AddFunctionId(0x00000514)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))
	return
}

// PlotHistogram2DV Plots two dimensional, bivariate histogram as a heatmap. #x_bins and #y_bins can be a positive integer or an ImPlotBin. If #range is left unspecified, the min/max of
// #xs an #ys will be used as the ranges. Otherwise, outlier values outside of range are not binned. The largest bin count or density is returned.
//foreign code:
//  r = ImPlot::PlotHistogram2D(label_id,xs,ys,(int)getSliceLength(xs),x_bins,y_bins,ImPlotRect(rangeP[0],rangeP[1],rangeP[2],rangeP[3]),flags)
func PlotHistogram2DUInt8V[T ~uint8](label_id string, xs []T, ys []T, x_bins ImPlotBin, y_bins ImPlotBin, rangeP ImPlotRect, flags ImPlotHistogramFlags) (r float64) {
	_f := currentFffiVar
	_f.AddFunctionId(0x00000515)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	runtime.AddIntArg(_f, x_bins)
	runtime.AddIntArg(_f, y_bins)
	runtime.AddFloat64Array4Arg(_f, rangeP)
	runtime.AddIntArg(_f, flags)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = (runtime.GetFloat64Retr[float64](_f))

	return
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotInfLinesFloat32[T ~float32](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000516)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotInfLinesFloat32V[T ~float32](label_id string, values []T, flags ImPlotInfLinesFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000517)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotInfLinesFloat64[T ~float64](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000518)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotInfLinesFloat64V[T ~float64](label_id string, values []T, flags ImPlotInfLinesFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000519)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotInfLinesInt[T ~int](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000051a)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	_f.CallProcedure()
}

func PlotInfLinesIntV[T ~int](label_id string, values []T, flags ImPlotInfLinesFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000051b)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotInfLinesInt16[T ~int16](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000051c)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotInfLinesInt16V[T ~int16](label_id string, values []T, flags ImPlotInfLinesFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000051d)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotInfLinesInt32[T ~int32](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000051e)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotInfLinesInt32V[T ~int32](label_id string, values []T, flags ImPlotInfLinesFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000051f)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotInfLinesInt8[T ~int8](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000520)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotInfLinesInt8V[T ~int8](label_id string, values []T, flags ImPlotInfLinesFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000521)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotInfLinesUInt[T ~uint](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000522)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	_f.CallProcedure()
}

func PlotInfLinesUIntV[T ~uint](label_id string, values []T, flags ImPlotInfLinesFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000523)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotInfLinesUInt16[T ~uint16](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000524)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotInfLinesUInt16V[T ~uint16](label_id string, values []T, flags ImPlotInfLinesFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000525)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotInfLinesUInt32[T ~uint32](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000526)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotInfLinesUInt32V[T ~uint32](label_id string, values []T, flags ImPlotInfLinesFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000527)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotInfLinesUInt8[T ~uint8](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000528)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotInfLinesUInt8V[T ~uint8](label_id string, values []T, flags ImPlotInfLinesFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000529)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotLineFloat32[T ~float32](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000052a)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotLineFloat32V[T ~float32](label_id string, values []T, xscale float64, xstart float64, flags ImPlotLineFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000052b)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotLineXYFloat32(label_id string, xs []float32, ys []float32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000052c)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotLineXYFloat32V(label_id string, xs []float32, ys []float32, flags ImPlotLineFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000052d)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotLineFloat64[T ~float64](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000052e)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotLineFloat64V[T ~float64](label_id string, values []T, xscale float64, xstart float64, flags ImPlotLineFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000052f)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotLineXYFloat64(label_id string, xs []float64, ys []float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000530)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotLineXYFloat64V(label_id string, xs []float64, ys []float64, flags ImPlotLineFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000531)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotLineInt[T ~int](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000532)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	_f.CallProcedure()
}

func PlotLineIntV[T ~int](label_id string, values []T, xscale float64, xstart float64, flags ImPlotLineFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000533)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotLineXYInt(label_id string, xs []int, ys []int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000534)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotLineXYIntV(label_id string, xs []int, ys []int, flags ImPlotLineFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000535)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotLineInt16[T ~int16](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000536)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotLineInt16V[T ~int16](label_id string, values []T, xscale float64, xstart float64, flags ImPlotLineFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000537)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotLineXYInt16(label_id string, xs []int16, ys []int16) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000538)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotLineXYInt16V(label_id string, xs []int16, ys []int16, flags ImPlotLineFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000539)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotLineInt32[T ~int32](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000053a)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotLineInt32V[T ~int32](label_id string, values []T, xscale float64, xstart float64, flags ImPlotLineFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000053b)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotLineXYInt32(label_id string, xs []int32, ys []int32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000053c)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotLineXYInt32V(label_id string, xs []int32, ys []int32, flags ImPlotLineFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000053d)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotLineInt8[T ~int8](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000053e)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotLineInt8V[T ~int8](label_id string, values []T, xscale float64, xstart float64, flags ImPlotLineFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000053f)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotLineXYInt8(label_id string, xs []int8, ys []int8) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000540)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotLineXYInt8V(label_id string, xs []int8, ys []int8, flags ImPlotLineFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000541)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotLineUInt[T ~uint](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000542)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	_f.CallProcedure()
}

func PlotLineUIntV[T ~uint](label_id string, values []T, xscale float64, xstart float64, flags ImPlotLineFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000543)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotLineXYUInt(label_id string, xs []uint, ys []uint) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000544)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotLineXYUIntV(label_id string, xs []uint, ys []uint, flags ImPlotLineFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000545)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotLineUInt16[T ~uint16](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000546)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotLineUInt16V[T ~uint16](label_id string, values []T, xscale float64, xstart float64, flags ImPlotLineFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000547)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotLineXYUInt16(label_id string, xs []uint16, ys []uint16) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000548)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotLineXYUInt16V(label_id string, xs []uint16, ys []uint16, flags ImPlotLineFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000549)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotLineUInt32[T ~uint32](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000054a)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotLineUInt32V[T ~uint32](label_id string, values []T, xscale float64, xstart float64, flags ImPlotLineFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000054b)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotLineXYUInt32(label_id string, xs []uint32, ys []uint32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000054c)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotLineXYUInt32V(label_id string, xs []uint32, ys []uint32, flags ImPlotLineFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000054d)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotLineUInt8[T ~uint8](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000054e)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotLineUInt8V[T ~uint8](label_id string, values []T, xscale float64, xstart float64, flags ImPlotLineFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000054f)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotLineXYUInt8(label_id string, xs []uint8, ys []uint8) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000550)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotLineXYUInt8V(label_id string, xs []uint8, ys []uint8, flags ImPlotLineFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000551)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotPieChartFloat32[T ~float32](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000552)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddFloat32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	_f.CallProcedure()
}

func PlotPieChartFloat32V[T ~float32](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags ImPlotPieChartFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000553)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddFloat32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddFloat64Arg(_f, angle0)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotPieChartFloat64[T ~float64](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000554)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddFloat64SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	_f.CallProcedure()
}

func PlotPieChartFloat64V[T ~float64](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags ImPlotPieChartFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000555)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddFloat64SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddFloat64Arg(_f, angle0)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotPieChartInt[T ~int](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000556)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddIntSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	_f.CallProcedure()
}

func PlotPieChartIntV[T ~int](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags ImPlotPieChartFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000557)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddIntSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddFloat64Arg(_f, angle0)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotPieChartInt16[T ~int16](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000558)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddInt16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	_f.CallProcedure()
}

func PlotPieChartInt16V[T ~int16](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags ImPlotPieChartFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000559)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddInt16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddFloat64Arg(_f, angle0)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotPieChartInt32[T ~int32](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000055a)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddInt32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	_f.CallProcedure()
}

func PlotPieChartInt32V[T ~int32](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags ImPlotPieChartFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000055b)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddInt32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddFloat64Arg(_f, angle0)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotPieChartInt8[T ~int8](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000055c)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddInt8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	_f.CallProcedure()
}

func PlotPieChartInt8V[T ~int8](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags ImPlotPieChartFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000055d)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddInt8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddFloat64Arg(_f, angle0)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotPieChartUInt[T ~uint](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000055e)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUintSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	_f.CallProcedure()
}

func PlotPieChartUIntV[T ~uint](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags ImPlotPieChartFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000055f)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUintSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddFloat64Arg(_f, angle0)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotPieChartUInt16[T ~uint16](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000560)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUint16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	_f.CallProcedure()
}

func PlotPieChartUInt16V[T ~uint16](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags ImPlotPieChartFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000561)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUint16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddFloat64Arg(_f, angle0)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotPieChartUInt32[T ~uint32](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000562)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUint32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	_f.CallProcedure()
}

func PlotPieChartUInt32V[T ~uint32](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags ImPlotPieChartFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000563)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUint32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddFloat64Arg(_f, angle0)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotPieChartUInt8[T ~uint8](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000564)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUint8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	_f.CallProcedure()
}

func PlotPieChartUInt8V[T ~uint8](label_ids NullSeparatedStringArray, values []T, x float64, y float64, radius float64, label_fmt string, angle0 float64, flags ImPlotPieChartFlags) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000565)
	runtime.AddStringArg(_f, label_ids)
	runtime.AddUint8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, x)
	runtime.AddFloat64Arg(_f, y)
	runtime.AddFloat64Arg(_f, radius)
	runtime.AddStringArg(_f, label_fmt)
	runtime.AddFloat64Arg(_f, angle0)
	runtime.AddIntArg(_f, flags)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotScatterFloat32(label_id string, values []float32) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000566)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotScatterFloat32V(label_id string, values []float32, xscale float64, xstart float64, flags ImPlotScatterFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000567)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotScatterXYFloat32(label_id string, xs []float32, ys []float32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000568)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotScatterXYFloat32V(label_id string, xs []float32, ys []float32, flags ImPlotScatterFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000569)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotScatterFloat64(label_id string, values []float64) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000056a)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotScatterFloat64V(label_id string, values []float64, xscale float64, xstart float64, flags ImPlotScatterFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000056b)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotScatterXYFloat64(label_id string, xs []float64, ys []float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000056c)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotScatterXYFloat64V(label_id string, xs []float64, ys []float64, flags ImPlotScatterFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000056d)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotScatterInt(label_id string, values []int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000056e)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	_f.CallProcedure()
}

func PlotScatterIntV(label_id string, values []int, xscale float64, xstart float64, flags ImPlotScatterFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000056f)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotScatterXYInt(label_id string, xs []int, ys []int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000570)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotScatterXYIntV(label_id string, xs []int, ys []int, flags ImPlotScatterFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000571)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotScatterInt16(label_id string, values []int16) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000572)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotScatterInt16V(label_id string, values []int16, xscale float64, xstart float64, flags ImPlotScatterFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000573)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotScatterXYInt16(label_id string, xs []int16, ys []int16) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000574)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotScatterXYInt16V(label_id string, xs []int16, ys []int16, flags ImPlotScatterFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000575)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotScatterInt32(label_id string, values []int32) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000576)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotScatterInt32V(label_id string, values []int32, xscale float64, xstart float64, flags ImPlotScatterFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000577)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotScatterXYInt32(label_id string, xs []int32, ys []int32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000578)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotScatterXYInt32V(label_id string, xs []int32, ys []int32, flags ImPlotScatterFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000579)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotScatterInt8(label_id string, values []int8) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000057a)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotScatterInt8V(label_id string, values []int8, xscale float64, xstart float64, flags ImPlotScatterFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000057b)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotScatterXYInt8(label_id string, xs []int8, ys []int8) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000057c)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotScatterXYInt8V(label_id string, xs []int8, ys []int8, flags ImPlotScatterFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000057d)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotScatterUInt(label_id string, values []uint) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000057e)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	_f.CallProcedure()
}

func PlotScatterUIntV(label_id string, values []uint, xscale float64, xstart float64, flags ImPlotScatterFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000057f)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotScatterXYUInt(label_id string, xs []uint, ys []uint) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000580)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotScatterXYUIntV(label_id string, xs []uint, ys []uint, flags ImPlotScatterFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000581)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotScatterUInt16(label_id string, values []uint16) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000582)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotScatterUInt16V(label_id string, values []uint16, xscale float64, xstart float64, flags ImPlotScatterFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000583)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotScatterXYUInt16(label_id string, xs []uint16, ys []uint16) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000584)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotScatterXYUInt16V(label_id string, xs []uint16, ys []uint16, flags ImPlotScatterFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000585)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotScatterUInt32(label_id string, values []uint32) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000586)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotScatterUInt32V(label_id string, values []uint32, xscale float64, xstart float64, flags ImPlotScatterFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000587)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotScatterXYUInt32(label_id string, xs []uint32, ys []uint32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000588)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotScatterXYUInt32V(label_id string, xs []uint32, ys []uint32, flags ImPlotScatterFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000589)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotScatterUInt8(label_id string, values []uint8) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000058a)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotScatterUInt8V(label_id string, values []uint8, xscale float64, xstart float64, flags ImPlotScatterFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000058b)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotScatterXYUInt8(label_id string, xs []uint8, ys []uint8) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000058c)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotScatterXYUInt8V(label_id string, xs []uint8, ys []uint8, flags ImPlotScatterFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000058d)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotShadedFloat32(label_id string, values []float32) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000058e)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotShadedFloat32V(label_id string, values []float32, yref float64, xscale float64, xstart float64, flags ImPlotShadedFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000058f)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotShadedXYFloat32(label_id string, xs []float32, ys []float32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000590)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotShadedXYFloat32V(label_id string, xs []float32, ys []float32, yref float64, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000591)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}

func PlotShadedXY1Y2Float32(label_id string, xs []float32, y1s []float32, y2s []float32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000592)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, y1s)
	runtime.AddFloat32SliceArg(_f, y2s)
	_f.CallProcedure()

}

func PlotShadedXY1Y2Float32V(label_id string, xs []float32, y1s []float32, y2s []float32, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000593)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, y1s)
	runtime.AddFloat32SliceArg(_f, y2s)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotShadedFloat64(label_id string, values []float64) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000594)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotShadedFloat64V(label_id string, values []float64, yref float64, xscale float64, xstart float64, flags ImPlotShadedFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000595)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotShadedXYFloat64(label_id string, xs []float64, ys []float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000596)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotShadedXYFloat64V(label_id string, xs []float64, ys []float64, yref float64, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000597)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}

func PlotShadedXY1Y2Float64(label_id string, xs []float64, y1s []float64, y2s []float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000598)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, y1s)
	runtime.AddFloat64SliceArg(_f, y2s)
	_f.CallProcedure()

}

func PlotShadedXY1Y2Float64V(label_id string, xs []float64, y1s []float64, y2s []float64, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000599)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, y1s)
	runtime.AddFloat64SliceArg(_f, y2s)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotShadedInt(label_id string, values []int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000059a)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	_f.CallProcedure()
}

func PlotShadedIntV(label_id string, values []int, yref float64, xscale float64, xstart float64, flags ImPlotShadedFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000059b)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotShadedXYInt(label_id string, xs []int, ys []int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000059c)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotShadedXYIntV(label_id string, xs []int, ys []int, yref float64, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000059d)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}

func PlotShadedXY1Y2Int(label_id string, xs []int, y1s []int, y2s []int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000059e)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, y1s)
	runtime.AddIntSliceArg(_f, y2s)
	_f.CallProcedure()

}

func PlotShadedXY1Y2IntV(label_id string, xs []int, y1s []int, y2s []int, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000059f)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, y1s)
	runtime.AddIntSliceArg(_f, y2s)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotShadedInt16(label_id string, values []int16) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005a0)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotShadedInt16V(label_id string, values []int16, yref float64, xscale float64, xstart float64, flags ImPlotShadedFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005a1)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotShadedXYInt16(label_id string, xs []int16, ys []int16) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005a2)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotShadedXYInt16V(label_id string, xs []int16, ys []int16, yref float64, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005a3)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}

func PlotShadedXY1Y2Int16(label_id string, xs []int16, y1s []int16, y2s []int16) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005a4)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, y1s)
	runtime.AddInt16SliceArg(_f, y2s)
	_f.CallProcedure()

}

func PlotShadedXY1Y2Int16V(label_id string, xs []int16, y1s []int16, y2s []int16, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005a5)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, y1s)
	runtime.AddInt16SliceArg(_f, y2s)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotShadedInt32(label_id string, values []int32) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005a6)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotShadedInt32V(label_id string, values []int32, yref float64, xscale float64, xstart float64, flags ImPlotShadedFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005a7)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotShadedXYInt32(label_id string, xs []int32, ys []int32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005a8)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotShadedXYInt32V(label_id string, xs []int32, ys []int32, yref float64, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005a9)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}

func PlotShadedXY1Y2Int32(label_id string, xs []int32, y1s []int32, y2s []int32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005aa)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, y1s)
	runtime.AddInt32SliceArg(_f, y2s)
	_f.CallProcedure()

}

func PlotShadedXY1Y2Int32V(label_id string, xs []int32, y1s []int32, y2s []int32, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005ab)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, y1s)
	runtime.AddInt32SliceArg(_f, y2s)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotShadedInt8(label_id string, values []int8) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005ac)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotShadedInt8V(label_id string, values []int8, yref float64, xscale float64, xstart float64, flags ImPlotShadedFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005ad)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotShadedXYInt8(label_id string, xs []int8, ys []int8) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005ae)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotShadedXYInt8V(label_id string, xs []int8, ys []int8, yref float64, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005af)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}

func PlotShadedXY1Y2Int8(label_id string, xs []int8, y1s []int8, y2s []int8) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005b0)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, y1s)
	runtime.AddInt8SliceArg(_f, y2s)
	_f.CallProcedure()

}

func PlotShadedXY1Y2Int8V(label_id string, xs []int8, y1s []int8, y2s []int8, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005b1)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, y1s)
	runtime.AddInt8SliceArg(_f, y2s)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotShadedUInt(label_id string, values []uint) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005b2)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	_f.CallProcedure()
}

func PlotShadedUIntV(label_id string, values []uint, yref float64, xscale float64, xstart float64, flags ImPlotShadedFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005b3)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotShadedXYUInt(label_id string, xs []uint, ys []uint) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005b4)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotShadedXYUIntV(label_id string, xs []uint, ys []uint, yref float64, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005b5)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}

func PlotShadedXY1Y2UInt(label_id string, xs []uint, y1s []uint, y2s []uint) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005b6)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, y1s)
	runtime.AddUintSliceArg(_f, y2s)
	_f.CallProcedure()

}

func PlotShadedXY1Y2UIntV(label_id string, xs []uint, y1s []uint, y2s []uint, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005b7)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, y1s)
	runtime.AddUintSliceArg(_f, y2s)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotShadedUInt16(label_id string, values []uint16) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005b8)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotShadedUInt16V(label_id string, values []uint16, yref float64, xscale float64, xstart float64, flags ImPlotShadedFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005b9)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotShadedXYUInt16(label_id string, xs []uint16, ys []uint16) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005ba)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotShadedXYUInt16V(label_id string, xs []uint16, ys []uint16, yref float64, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005bb)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}

func PlotShadedXY1Y2UInt16(label_id string, xs []uint16, y1s []uint16, y2s []uint16) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005bc)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, y1s)
	runtime.AddUint16SliceArg(_f, y2s)
	_f.CallProcedure()

}

func PlotShadedXY1Y2UInt16V(label_id string, xs []uint16, y1s []uint16, y2s []uint16, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005bd)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, y1s)
	runtime.AddUint16SliceArg(_f, y2s)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotShadedUInt32(label_id string, values []uint32) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005be)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotShadedUInt32V(label_id string, values []uint32, yref float64, xscale float64, xstart float64, flags ImPlotShadedFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005bf)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotShadedXYUInt32(label_id string, xs []uint32, ys []uint32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005c0)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotShadedXYUInt32V(label_id string, xs []uint32, ys []uint32, yref float64, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005c1)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}

func PlotShadedXY1Y2UInt32(label_id string, xs []uint32, y1s []uint32, y2s []uint32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005c2)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, y1s)
	runtime.AddUint32SliceArg(_f, y2s)
	_f.CallProcedure()

}

func PlotShadedXY1Y2UInt32V(label_id string, xs []uint32, y1s []uint32, y2s []uint32, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005c3)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, y1s)
	runtime.AddUint32SliceArg(_f, y2s)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotShadedUInt8(label_id string, values []uint8) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005c4)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotShadedUInt8V(label_id string, values []uint8, yref float64, xscale float64, xstart float64, flags ImPlotShadedFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005c5)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotShadedXYUInt8(label_id string, xs []uint8, ys []uint8) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005c6)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotShadedXYUInt8V(label_id string, xs []uint8, ys []uint8, yref float64, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005c7)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, yref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}

func PlotShadedXY1Y2UInt8(label_id string, xs []uint8, y1s []uint8, y2s []uint8) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005c8)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, y1s)
	runtime.AddUint8SliceArg(_f, y2s)
	_f.CallProcedure()

}

func PlotShadedXY1Y2UInt8V(label_id string, xs []uint8, y1s []uint8, y2s []uint8, flags ImPlotShadedFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005c9)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, y1s)
	runtime.AddUint8SliceArg(_f, y2s)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStairsFloat32(label_id string, values []float32) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005ca)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStairsFloat32V(label_id string, values []float32, xscale float64, xstart float64, flags ImPlotStairsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005cb)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStairsXYFloat32(label_id string, xs []float32, ys []float32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005cc)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStairsXYFloat32V(label_id string, xs []float32, ys []float32, flags ImPlotStairsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005cd)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStairsFloat64(label_id string, values []float64) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005ce)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStairsFloat64V(label_id string, values []float64, xscale float64, xstart float64, flags ImPlotStairsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005cf)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStairsXYFloat64(label_id string, xs []float64, ys []float64) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005d0)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStairsXYFloat64V(label_id string, xs []float64, ys []float64, flags ImPlotStairsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005d1)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStairsInt(label_id string, values []int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005d2)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStairsIntV(label_id string, values []int, xscale float64, xstart float64, flags ImPlotStairsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005d3)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStairsXYInt(label_id string, xs []int, ys []int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005d4)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStairsXYIntV(label_id string, xs []int, ys []int, flags ImPlotStairsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005d5)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStairsInt16(label_id string, values []int16) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005d6)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStairsInt16V(label_id string, values []int16, xscale float64, xstart float64, flags ImPlotStairsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005d7)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStairsXYInt16(label_id string, xs []int16, ys []int16) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005d8)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStairsXYInt16V(label_id string, xs []int16, ys []int16, flags ImPlotStairsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005d9)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStairsInt32(label_id string, values []int32) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005da)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStairsInt32V(label_id string, values []int32, xscale float64, xstart float64, flags ImPlotStairsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005db)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStairsXYInt32(label_id string, xs []int32, ys []int32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005dc)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStairsXYInt32V(label_id string, xs []int32, ys []int32, flags ImPlotStairsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005dd)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStairsInt8(label_id string, values []int8) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005de)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStairsInt8V(label_id string, values []int8, xscale float64, xstart float64, flags ImPlotStairsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005df)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStairsXYInt8(label_id string, xs []int8, ys []int8) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005e0)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStairsXYInt8V(label_id string, xs []int8, ys []int8, flags ImPlotStairsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005e1)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStairsUInt(label_id string, values []uint) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005e2)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStairsUIntV(label_id string, values []uint, xscale float64, xstart float64, flags ImPlotStairsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005e3)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStairsXYUInt(label_id string, xs []uint, ys []uint) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005e4)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStairsXYUIntV(label_id string, xs []uint, ys []uint, flags ImPlotStairsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005e5)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStairsUInt16(label_id string, values []uint16) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005e6)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStairsUInt16V(label_id string, values []uint16, xscale float64, xstart float64, flags ImPlotStairsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005e7)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStairsXYUInt16(label_id string, xs []uint16, ys []uint16) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005e8)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStairsXYUInt16V(label_id string, xs []uint16, ys []uint16, flags ImPlotStairsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005e9)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStairsUInt32(label_id string, values []uint32) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005ea)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStairsUInt32V(label_id string, values []uint32, xscale float64, xstart float64, flags ImPlotStairsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005eb)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStairsXYUInt32(label_id string, xs []uint32, ys []uint32) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005ec)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStairsXYUInt32V(label_id string, xs []uint32, ys []uint32, flags ImPlotStairsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005ed)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStairsUInt8(label_id string, values []uint8) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005ee)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStairsUInt8V(label_id string, values []uint8, xscale float64, xstart float64, flags ImPlotStairsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005ef)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, xscale)
	runtime.AddFloat64Arg(_f, xstart)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStairsXYUInt8(label_id string, xs []uint8, ys []uint8) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005f0)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStairsXYUInt8V(label_id string, xs []uint8, ys []uint8, flags ImPlotStairsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005f1)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStemsFloat32[T ~float32](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005f2)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStemsFloat32V[T ~float32](label_id string, values []T, ref float64, scale float64, start float64, flags ImPlotStemsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005f3)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddFloat64Arg(_f, scale)
	runtime.AddFloat64Arg(_f, start)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStemsXYFloat32[T ~float32](label_id string, xs []T, ys []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005f4)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStemsXYFloat32V[T ~float32](label_id string, xs []T, ys []T, ref float64, flags ImPlotStemsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005f5)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat32SliceArg(_f, xs)
	runtime.AddFloat32SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStemsFloat64[T ~float64](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005f6)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStemsFloat64V[T ~float64](label_id string, values []T, ref float64, scale float64, start float64, flags ImPlotStemsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005f7)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddFloat64Arg(_f, scale)
	runtime.AddFloat64Arg(_f, start)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStemsXYFloat64[T ~float64](label_id string, xs []T, ys []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005f8)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStemsXYFloat64V[T ~float64](label_id string, xs []T, ys []T, ref float64, flags ImPlotStemsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005f9)
	runtime.AddStringArg(_f, label_id)
	runtime.AddFloat64SliceArg(_f, xs)
	runtime.AddFloat64SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStemsInt[T ~int](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005fa)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStemsIntV[T ~int](label_id string, values []T, ref float64, scale float64, start float64, flags ImPlotStemsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005fb)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddFloat64Arg(_f, scale)
	runtime.AddFloat64Arg(_f, start)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStemsXYInt[T ~int](label_id string, xs []T, ys []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005fc)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStemsXYIntV[T ~int](label_id string, xs []T, ys []T, ref float64, flags ImPlotStemsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x000005fd)
	runtime.AddStringArg(_f, label_id)
	runtime.AddIntSliceArg(_f, xs)
	runtime.AddIntSliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStemsInt16[T ~int16](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005fe)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStemsInt16V[T ~int16](label_id string, values []T, ref float64, scale float64, start float64, flags ImPlotStemsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x000005ff)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddFloat64Arg(_f, scale)
	runtime.AddFloat64Arg(_f, start)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStemsXYInt16[T ~int16](label_id string, xs []T, ys []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000600)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStemsXYInt16V[T ~int16](label_id string, xs []T, ys []T, ref float64, flags ImPlotStemsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000601)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt16SliceArg(_f, xs)
	runtime.AddInt16SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStemsInt32[T ~int32](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000602)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStemsInt32V[T ~int32](label_id string, values []T, ref float64, scale float64, start float64, flags ImPlotStemsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000603)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddFloat64Arg(_f, scale)
	runtime.AddFloat64Arg(_f, start)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStemsXYInt32[T ~int32](label_id string, xs []T, ys []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000604)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStemsXYInt32V[T ~int32](label_id string, xs []T, ys []T, ref float64, flags ImPlotStemsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000605)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt32SliceArg(_f, xs)
	runtime.AddInt32SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStemsInt8[T ~int8](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000606)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStemsInt8V[T ~int8](label_id string, values []T, ref float64, scale float64, start float64, flags ImPlotStemsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000607)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddFloat64Arg(_f, scale)
	runtime.AddFloat64Arg(_f, start)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStemsXYInt8[T ~int8](label_id string, xs []T, ys []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000608)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStemsXYInt8V[T ~int8](label_id string, xs []T, ys []T, ref float64, flags ImPlotStemsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000609)
	runtime.AddStringArg(_f, label_id)
	runtime.AddInt8SliceArg(_f, xs)
	runtime.AddInt8SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStemsUInt[T ~uint](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000060a)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStemsUIntV[T ~uint](label_id string, values []T, ref float64, scale float64, start float64, flags ImPlotStemsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000060b)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, values)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddFloat64Arg(_f, scale)
	runtime.AddFloat64Arg(_f, start)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStemsXYUInt[T ~uint](label_id string, xs []T, ys []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000060c)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStemsXYUIntV[T ~uint](label_id string, xs []T, ys []T, ref float64, flags ImPlotStemsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x0000060d)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUintSliceArg(_f, xs)
	runtime.AddUintSliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStemsUInt16[T ~uint16](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000060e)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStemsUInt16V[T ~uint16](label_id string, values []T, ref float64, scale float64, start float64, flags ImPlotStemsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000060f)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddFloat64Arg(_f, scale)
	runtime.AddFloat64Arg(_f, start)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStemsXYUInt16[T ~uint16](label_id string, xs []T, ys []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000610)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStemsXYUInt16V[T ~uint16](label_id string, xs []T, ys []T, ref float64, flags ImPlotStemsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000611)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint16SliceArg(_f, xs)
	runtime.AddUint16SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStemsUInt32[T ~uint32](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000612)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStemsUInt32V[T ~uint32](label_id string, values []T, ref float64, scale float64, start float64, flags ImPlotStemsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000613)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddFloat64Arg(_f, scale)
	runtime.AddFloat64Arg(_f, start)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStemsXYUInt32[T ~uint32](label_id string, xs []T, ys []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000614)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStemsXYUInt32V[T ~uint32](label_id string, xs []T, ys []T, ref float64, flags ImPlotStemsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000615)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint32SliceArg(_f, xs)
	runtime.AddUint32SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func PlotStemsUInt8[T ~uint8](label_id string, values []T) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000616)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	_f.CallProcedure()
}

func PlotStemsUInt8V[T ~uint8](label_id string, values []T, ref float64, scale float64, start float64, flags ImPlotStemsFlags, offset int, stride int) {

	_f := currentFffiVar
	_f.AddProcedureId(0x00000617)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, values)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddFloat64Arg(_f, scale)
	runtime.AddFloat64Arg(_f, start)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()
}

func PlotStemsXYUInt8[T ~uint8](label_id string, xs []T, ys []T) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000618)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	_f.CallProcedure()

}

func PlotStemsXYUInt8V[T ~uint8](label_id string, xs []T, ys []T, ref float64, flags ImPlotStemsFlags, offset int, stride int) {
	_f := currentFffiVar
	_f.AddProcedureId(0x00000619)
	runtime.AddStringArg(_f, label_id)
	runtime.AddUint8SliceArg(_f, xs)
	runtime.AddUint8SliceArg(_f, ys)
	runtime.AddFloat64Arg(_f, ref)
	runtime.AddIntArg(_f, flags)
	runtime.AddIntArg(_f, offset)
	runtime.AddIntArg(_f, stride)
	_f.CallProcedure()

}
// -- deactivated -- // //go:build fffi_idl_code

// -- deactivated -- // package implot

func loadStyle(ptr ImPlotStyleForeignPtr, bs []bool, fs []float32, vec2s []float32, cols []float32, markers []int, maps []ImPlotColormap) {

	_f := currentFffiVar
	_f.AddProcedureId(0x0000061a)
	runtime.AddUintptrArg(_f, ptr)
	runtime.AddBoolSliceArg(_f, bs)
	runtime.AddFloat32SliceArg(_f, fs)
	runtime.AddFloat32SliceArg(_f, vec2s)
	runtime.AddFloat32SliceArg(_f, cols)
	runtime.AddIntSliceArg(_f, markers)
	runtime.AddIntSliceArg(_f, maps)
	_f.CallProcedure()

	return
}

func GetStyle() (r ImPlotStyleForeignPtr) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000061b)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	r = ImPlotStyleForeignPtr(runtime.GetUintptrRetr[uintptr](_f))

	return
}

func dumpStyle(ptr ImPlotStyleForeignPtr) (bs []bool, fs []float32, vec2s []float32, cols []float32, markers []int, maps []ImPlotColormap) {
	_f := currentFffiVar
	_f.AddFunctionId(0x0000061c)
	runtime.AddUintptrArg(_f, ptr)
	_err_ := _f.CallFunction()
	if _err_ != nil {
		currentFffiErrorHandler(_err_)
		return
	}
	bs = (runtime.GetBoolSliceRetr[bool](_f))
	fs = (runtime.GetFloat32SliceRetr[float32](_f))
	vec2s = (runtime.GetFloat32SliceRetr[float32](_f))
	cols = (runtime.GetFloat32SliceRetr[float32](_f))
	markers = (runtime.GetIntSliceRetr[int](_f))
	maps = runtime.GetIntSliceRetr[ImPlotColormap](_f)

	return
}
