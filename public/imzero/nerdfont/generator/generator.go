package generator

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode/utf8"

	"github.com/go-json-experiment/json"
	"github.com/rs/zerolog/log"
	"github.com/stergiotis/boxer/public/observability/eh"
	"github.com/stergiotis/boxer/public/observability/eh/eb"
	"github.com/urfave/cli/v2"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type NerdFontJsonMetaData struct {
	Metadata struct {
		Website            string `json:"website"`
		DevelopmentWebsite string `json:"development-website"`
		Version            string `json:"version"`
		Date               string `json:"date"`
	} `json:"METADATA"`
}
type NerdFontGlyph struct {
	Char string `json:"char"`
	Code string `json:"code"`
}
type NerdFontGlyphLibrary map[string]*NerdFontGlyph

type Generator struct {
	meta   *NerdFontJsonMetaData
	glyphs NerdFontGlyphLibrary
}

func NewGenerator() *Generator {
	return &Generator{}
}
func (inst *Generator) Load(jsonDoc []byte) (err error) {
	inst.meta = &NerdFontJsonMetaData{}
	inst.glyphs = NerdFontGlyphLibrary(make(map[string]*NerdFontGlyph, 100000))
	err = json.Unmarshal(jsonDoc, inst.meta)
	if err != nil {
		err = eh.Errorf("unable to load json metadata part: %w", err)
		return
	}
	err = json.Unmarshal(jsonDoc, &inst.glyphs)
	if err != nil {
		err = eh.Errorf("unable to load json glyphs part: %w", err)
		return
	}
	delete(inst.glyphs, "METADATA")
	return
}

const banner = `// Code generated by imzero nerdfont generator; DO NOT EDIT.`

func (inst *Generator) GenerateGo(staticGlyphFile io.StringWriter, staticPackage string, dynamicGlyphFile io.StringWriter, dynamicPackage string) {
	_, _ = staticGlyphFile.WriteString(banner)
	_, _ = staticGlyphFile.WriteString("\npackage ")
	_, _ = staticGlyphFile.WriteString(staticPackage)
	_, _ = staticGlyphFile.WriteString("\n\n")

	_, _ = dynamicGlyphFile.WriteString(banner)
	_, _ = dynamicGlyphFile.WriteString("\npackage ")
	_, _ = dynamicGlyphFile.WriteString(dynamicPackage)
	_, _ = dynamicGlyphFile.WriteString("\n\n")

	_, _ = staticGlyphFile.WriteString("const (\n")
	glyphs := inst.glyphs
	glyphsS := make([]string, 0, len(glyphs))
	glyphsS2 := make([]string, 0, len(glyphs))
	for n, _ := range glyphs {
		glyphsS = append(glyphsS, n)
	}
	caser := cases.Upper(language.English)
	sort.Strings(glyphsS)
	tmp := make(map[string]struct{}, len(glyphs))
	b := strings.Builder{}
	maxCp := rune(0)
	codePoints := make([]string, 0, len(glyphsS))
	for j, s := range glyphsS {
		_, _ = staticGlyphFile.WriteString("  ")
		upperCase := true
		b.Reset()
		for _, r := range s {
			if upperCase {
				_, _ = b.WriteString(caser.String(string(r)))
				upperCase = false
				continue
			}
			switch r {
			case '_', '-':
				upperCase = true
			default:
				_, _ = b.WriteString(string(r))
			}
		}
		name := b.String()
		i := 2
		_, has := tmp[name]
		if has {
			var name2 string
			for has {
				name2 = fmt.Sprintf("%s%d", name, i)
				_, has = tmp[name2]
				i++
			}
			log.Info().Str("name", name).Str("newName", name2).Str("orig", s).Msg("aliasing name")
			name = name2
		}
		tmp[name] = struct{}{}
		glyphsS2 = append(glyphsS2, fmt.Sprintf("%q", name))
		glyphsS[j] = fmt.Sprintf("%q", s)
		g := glyphs[s]
		cp, _ := utf8.DecodeRuneInString(g.Char)
		codePoints = append(codePoints, fmt.Sprintf("0x%08x", cp))
		if cp > maxCp {
			maxCp = cp
		}
		_, _ = staticGlyphFile.WriteString(fmt.Sprintf("  %s = %q\n", name, g.Char))
	}
	_, _ = staticGlyphFile.WriteString(")\n")

	_, _ = dynamicGlyphFile.WriteString(fmt.Sprintf("const MaxCodepoint rune = 0x%08x\n", maxCp))
	_, _ = dynamicGlyphFile.WriteString("var OriginalNames = []string{")
	_, _ = dynamicGlyphFile.WriteString(strings.Join(glyphsS, ",\n"))
	_, _ = dynamicGlyphFile.WriteString("}\n")
	_, _ = dynamicGlyphFile.WriteString("var Names = []string{")
	_, _ = dynamicGlyphFile.WriteString(strings.Join(glyphsS2, ",\n"))
	_, _ = dynamicGlyphFile.WriteString("}\n")
	_, _ = dynamicGlyphFile.WriteString("var CodePoints = []rune{")
	_, _ = dynamicGlyphFile.WriteString(strings.Join(codePoints, ",\n"))
	_, _ = dynamicGlyphFile.WriteString("}\n")
}
func NewCommand() *cli.Command {
	return &cli.Command{
		Name: "generate",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:     "glyphJson",
				Required: true,
			},
			&cli.StringFlag{
				Name:     "staticGlyphsGoFile",
				Required: true,
			},
			&cli.StringFlag{
				Name:     "dynamicGlyphsGoFile",
				Required: true,
			},
			&cli.StringFlag{
				Name:     "staticGlyphsGoPackage",
				Required: true,
			},
			&cli.StringFlag{
				Name:     "dynamicGlyphsGoPackage",
				Required: true,
			},
		},
		Action: func(context *cli.Context) error {
			path := context.String("glyphJson")
			js, err := os.ReadFile(path)
			if err != nil {
				return eb.Build().Str("path", path).Errorf("unable to read glyph json file")
			}
			gen := NewGenerator()
			err = gen.Load(js)
			if err != nil {
				return eb.Build().Str("path", path).Errorf("error while loading glyph json: %w", err)
			}

			staticGlyphsGoFile := context.String("staticGlyphsGoFile")
			dynamicGlyphsGoFile := context.String("dynamicGlyphsGoFile")
			_ = os.MkdirAll(filepath.Base(staticGlyphsGoFile), os.ModePerm)
			_ = os.MkdirAll(filepath.Base(dynamicGlyphsGoFile), os.ModePerm)

			var staticGlyphsW *os.File
			staticGlyphsW, err = os.Create(staticGlyphsGoFile)
			if err != nil {
				return eb.Build().Str("staticGlyphsGoFile", staticGlyphsGoFile).Errorf("unable to create static glyphs go file: %w", err)
			}
			defer staticGlyphsW.Close()

			var dynamicGlyphsW *os.File
			dynamicGlyphsW, err = os.Create(dynamicGlyphsGoFile)
			if err != nil {
				return eb.Build().Str("dynamicGlyphsGoFile", dynamicGlyphsGoFile).Errorf("unable to create dynamic glyphs go file: %w", err)
			}
			defer dynamicGlyphsW.Close()

			gen.GenerateGo(staticGlyphsW,
				context.String("staticGlyphsGoPackage"),
				dynamicGlyphsW,
				context.String("dynamicGlyphsGoPackage"))
			return nil
		},
	}
}
