// Code generated by copy paste; DO NOT EDIT.
package valueaspects

import (
	"iter"
	"math/bits"

	"github.com/rs/zerolog/log"
	"github.com/stergiotis/boxer/public/observability/eh"
	"github.com/stergiotis/boxer/public/observability/eh/eb"
	"github.com/stergiotis/boxer/public/semistructured/leeway/base62"
)

const EmptyAspectSet = AspectSet("0")

func countEncodedAspect(num uint64) (n int) {
	n = bits.OnesCount64(num)
	return
}
func maxEncodedAspect(num uint64) (maxEncoded AspectE) {
	maxEncoded = AspectE(64 - bits.LeadingZeros64(num) - 1)
	return
}
func decode(encoded AspectSet) (num uint64, valid bool) {
	num, valid = base62.Decode(base62.Base62Num(encoded))
	valid = valid && (num == 0 || maxEncodedAspect(num).IsValid())
	return
}
func encode(num uint64) (encoded AspectSet) {
	return AspectSet(base62.Encode(num))
}

var ErrInvalidEncoding = eh.Errorf("encoding is wrong")
var ErrEmptySet = eh.Errorf("encoding contains empty set")

func EncodeAspects(aspects ...AspectE) (encoded AspectSet, err error) {
	var num uint64
	for i, a := range aspects {
		if !a.IsValid() {
			err = eb.Build().Uint8("aspect", uint8(a)).Int("index", i).Errorf("found invalid aspect in supplied arguments")
			return
		}
		num |= uint64(1) << a
	}
	encoded = encode(num)
	return
}
func EncodeAspectsIgnoreInvalid(aspects ...AspectE) (encoded AspectSet) {
	var num uint64
	for _, a := range aspects {
		if a.IsValid() {
			num |= uint64(1) << a
		}
	}
	encoded = encode(num)
	return
}
func EncodeAspectsMustValidate(aspects ...AspectE) (encoded AspectSet) {
	var num uint64
	for i, a := range aspects {
		if !a.IsValid() {
			log.Panic().Uint8("aspect", uint8(a)).Int("index", i).Msg("found invalid aspect in supplied arguments")
		}
		num |= uint64(1) << a
	}
	encoded = encode(num)
	return
}
func MaxEncodedAspect(encoded AspectSet) (aspect AspectE, err error) {
	num, valid := decode(encoded)
	if !valid {
		err = ErrInvalidEncoding
		return
	}
	if num == 0 {
		err = ErrEmptySet
		return
	}
	aspect = maxEncodedAspect(num)
	return
}
func CountEncodedAspects(encoded AspectSet) (n int, err error) {
	num, valid := decode(encoded)
	if !valid {
		err = ErrInvalidEncoding
		return
	}
	n = countEncodedAspect(num)
	return
}
func IterateAspects(encoded AspectSet) iter.Seq2[int, AspectE] {
	num, valid := decode(encoded)
	if !valid {
		return nil
	}
	return func(yield func(int, AspectE) bool) {
		j := 0
		for i := uint8(0); i < uint8(MaxAspectExcl); i++ {
			if num&(uint64(1)<<i) != 0 {
				if !yield(j, AspectE(i)) {
					return
				}
				j++
			}
		}
	}
}
func UnionAspects(asp1 AspectSet, asp2 AspectSet) (res AspectSet, err error) {
	num1, valid1 := decode(asp1)
	if !valid1 {
		err = ErrInvalidEncoding
		return
	}
	num2, valid2 := decode(asp2)
	if !valid2 {
		err = ErrInvalidEncoding
		return
	}
	res = encode(num1 | num2)
	return
}
func UnionAspectsIgnoreInvalid(asp1 AspectSet, asp2 AspectSet) (res AspectSet) {
	num1, valid1 := decode(asp1)
	num2, valid2 := decode(asp2)
	if valid1 && valid2 {
		res = encode(num1 | num2)
	} else if valid1 {
		res = asp1
	} else if valid2 {
		res = asp2
	} else {
		res = EmptyAspectSet
	}
	return
}
func (inst AspectSet) String() string {
	return string(inst)
}

func (inst AspectSet) IsValid() bool {
	if inst == "" {
		return false
	}
	_, valid := decode(inst)
	return valid
}
func (inst AspectSet) IsEmptySet() bool {
	return inst == EmptyAspectSet
}
func (inst AspectSet) UnionAspectsIgnoreInvalid(asp2 AspectSet) (res AspectSet) {
	return UnionAspectsIgnoreInvalid(inst, asp2)
}
func (inst AspectSet) UnionAspects(asp2 AspectSet) (res AspectSet, err error) {
	return UnionAspects(inst, asp2)
}
func (inst AspectSet) IterateAspects() iter.Seq2[int, AspectE] {
	return IterateAspects(inst)
}
func (inst AspectSet) CountEncodedAspects() (n int, err error) {
	return CountEncodedAspects(inst)
}
func (inst AspectSet) MaxEncodedAspect() (aspect AspectE, err error) {
	return MaxEncodedAspect(inst)
}
