// Code generated by copy pase; DO NOT EDIT.
package encodingaspects

import (
	"regexp"
	"slices"
	"testing"

	"github.com/stergiotis/boxer/public/semistructured/leeway/naming"
	"github.com/stretchr/testify/require"
)

func TestCanonicalAspectEnum(t *testing.T) {
	require.EqualValues(t, len(AllAspects), MaxAspectExcl)
	m := make([]string, 0, len(AllAspects))
	for i := AspectE(0); i < MaxAspectExcl; i++ {
		require.False(t, slices.Contains(m, i.String()))
		m = append(m, i.String())
		require.True(t,naming.StylableName(i.String()).IsValid(), i.String())
	}
}
func TestCanonicalAspectCoder(t *testing.T) {
	rgx := regexp.MustCompile("[^a-zA-Z0-9]")
	{
		_, err := EncodeAspects(MaxAspectExcl)
		require.Error(t, err)
	}
	for i := AspectE(0); i < MaxAspectExcl; i++ {
		enc, err := EncodeAspects(i)
		require.NoError(t, err)
		for k, a := range IterateAspects(enc) {
			require.Equal(t, k, 0)
			require.Equal(t, a, i)
		}
		require.EqualValues(t, i, slices.Index(AllAspects, i))
		require.False(t, enc.IsEmptySet())

		var n int
		n, err = CountEncodedAspects(enc)
		require.NoError(t, err)
		require.EqualValues(t, 1, n)
	}
	for i := AspectE(0); i < MaxAspectExcl; i++ {
		for j := AspectE(0); j < MaxAspectExcl; j++ {
			enc, err := EncodeAspects(i, j)
			require.NoError(t, err)
			outer := false
			inner := false
			for k, a := range IterateAspects(enc) {
				require.Less(t, k, 2)
				if a == i {
					require.False(t, outer)
					outer = true
				}
				if a == j {
					require.False(t, inner)
					inner = true
				}
			}
			require.False(t, enc.IsEmptySet())

			var me AspectE
			me, err = MaxEncodedAspect(enc)
			require.NoError(t, err)
			require.EqualValues(t, max(i, j), me)

			require.False(t, rgx.MatchString(enc.String()))

			var n int
			n, err = CountEncodedAspects(enc)
			require.NoError(t, err)
			if i != j {
				require.EqualValues(t, 2, n)
			} else {
				require.EqualValues(t, 1, n)
			}

			{
				var enc1, enc2, encU AspectSet
				enc1, err = EncodeAspects(i)
				require.NoError(t, err)
				enc2, err = EncodeAspects(j)
				require.NoError(t, err)
				encU, err = UnionAspects(enc1, enc2)
				require.NoError(t, err)
				require.EqualValues(t, enc, encU)
			}
		}
	}
	require.True(t, EmptyAspectSet.IsEmptySet())
	{
		n, err := CountEncodedAspects(EmptyAspectSet)
		require.NoError(t, err)
		require.EqualValues(t, 0, n)
	}
}
